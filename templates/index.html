<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brew View - Potion Flow Monitoring</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #120b2f; /* dark purple background */
            min-height: 100vh;
        }
        
        .header {
            background: #2a173f; /* lighter purple than body #120b2f */
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.45);
        }
        
        .header h1 {
            color: #667eea;
            text-align: center;
            font-size: 2em;
        }
        .brand {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        .brand .logo {
            height: 44px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
        }
        
        .header p {
            text-align: center;
            color: rgba(255,255,255,0.85);
            margin-top: 5px;
        }
        
        /* Tabs */
        .tabs {
            max-width: 1400px;
            margin: 20px auto 0;
            padding: 0 20px;
            display: flex;
            gap: 10px;
        }
        
        .tab {
            background: #f5f5f5;
            border: none;
            padding: 12px 30px 15px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            border-radius: 8px 8px 0 0;
            transition: background 0.3s ease, color 0.3s ease;
            position: relative;
        }
        
        .tab:hover {
            background: #e8e8e8;
            color: #333;
        }
        
        .tab.active {
            background: #e6e6ea; /* slightly dimmer light gray */
            color: #667eea;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto 20px;
            padding: 0 20px;
        }
        
        .map-container {
            background: #e6e6ea; /* slightly dimmer light gray */
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        #map {
            height: 600px;
            width: 100%;
            border-radius: 8px;
        }

        /* Darken base map tiles so marker glow pops */
        .leaflet-tile-pane {
            filter: brightness(0.55) contrast(1.1) saturate(0.85);
        }
        /* Optional: slightly darker map background while tiles load */
        #map {
            background-color: #0f1324;
        }
        
        .info-panel {
            background: #e6e6ea; /* slightly dimmer light gray */
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #764ba2; /* solid purple */
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .stat-card p {
            opacity: 0.9;
            font-size: 0.9em;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #667eea;
        }
        
        .error {
            background: #fee;
            color: #c00;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        /* Timeline Slider */
        .timeline-container {
            background: #e6e6ea; /* slightly dimmer light gray */
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        
        .timeline-container h2 {
            margin-bottom: 20px;
        }
        
        .date-selector {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 15px;
        }
        
        .date-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .date-group label {
            font-weight: bold;
            margin-bottom: 5px;
            padding-bottom: 15px;
            color: #667eea;
            font-size: 16px;
            text-align: center;
        }
        
        .date-group select {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 14px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
            max-width: 120px;
        }
        
        .slider-row {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            margin-bottom: 15px;
        }
        
        .slider-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }
        
        .timeline-slider {
            width: 100%;
        }
        
        .timeline-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .timeline-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .show-btn-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .timeline-btn {
            background: #764ba2; /* solid purple */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .timeline-btn:hover {
            opacity: 0.9;
        }
        
        .timeline-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .show-btn {
            background: #764ba2; /* solid purple */
            font-size: 16px;
            font-weight: bold;
            padding: 10px 30px;
        }
        
        .timestamp-display {
            font-size: 1.1em;
            color: #667eea;
            font-weight: bold;
        }
        
        .time-slider-container {
            padding: 15px;
            background: #e6e6ea; /* slightly dimmer light gray */
            border-radius: 8px;
        }
        
        .time-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }
        
        /* Ticket Logs Styles */
        .ticket-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .ticket-table th {
            background: #764ba2; /* solid purple */
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .ticket-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .ticket-table tr:hover {
            background: #e6e6ea;
        }
        
        .ticket-table tr.suspicious {
            background: #ffe6e6;
        }
        
        .ticket-table tr.suspicious:hover {
            background: #ffd6d6;
        }
        
        .suspicious-badge {
            background: #ff4444;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .pagination button {
            background: #764ba2; /* solid purple */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination button:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        .pagination span {
            color: #667eea;
            font-weight: 600;
        }

        /* Ticket stat cards (Ticket Logs summary boxes) */
        .ticket-stat-card {
            background: #5b2a86; /* dark purple that blends with #764ba2 */
            color: #ffffff;
            padding: 12px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ticket-stat-card .ticket-stat-label {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 2px;
            font-weight: 600;
        }
        .ticket-stat-card .ticket-stat-value {
            color: #ffffff;
            font-size: 28px;
            font-weight: 700;
            line-height: 1;
        }
        .ticket-stat-card .ticket-stat-sub {
            color: rgba(255,255,255,0.85);
            font-size: 11px;
            margin-top: 4px;
        }
        .ticket-stat-muted {
            opacity: 0.8;
        }
        
        /* Ticket Filters */
        .ticket-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Dropdown checkbox container */
        .dropdown-filter {
            position: relative;
            width: 180px;
        }

        .dropdown-filter-toggle {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .dropdown-filter-toggle:hover {
            background: #f3f6ff;
        }

        .dropdown-filter-menu {
            position: absolute;
            top: 105%;
            left: 0;
            z-index: 50;
            background: #e6e6ea; /* slightly dimmer light gray */
            border: 2px solid #667eea;
            border-radius: 6px;
            max-height: 260px;
            overflow-y: auto;
            padding: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            display: none;
            width: 100%;
        }

        .dropdown-filter.open .dropdown-filter-menu {
            display: block;
        }

        /* Avoid nested scrollbars: let the menu scroll, not inner list */
        .dropdown-filter-menu .checkbox-group {
            max-height: none;
            overflow: visible;
            border: none;
            padding: 0;
        }
        
        .filter-group label {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
        }
        
        .filter-group select,
        .filter-group input {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 14px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
        }
        
        .checkbox-group {
            max-height: 150px;
            overflow-y: auto;
            border: 2px solid #667eea;
            border-radius: 5px;
            padding: 8px;
            background: #e6e6ea; /* slightly dimmer light gray */
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .checkbox-item label {
            font-weight: normal;
            color: #333;
            font-size: 13px;
            cursor: pointer;
            margin: 0;
        }
        
        .filter-group button {
            background: #764ba2; /* solid purple */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 23px;
        }
        
        .filter-group button:hover {
            opacity: 0.9;
        }
        
        /* Custom marker styles */
        /* Legacy circle marker (kept for reference)
        .cauldron-marker {
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        */
        .cauldron-img-wrapper {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .cauldron-img {
            width: 28px;
            height: 28px;
            object-fit: contain;
            pointer-events: none;
        }
        .glow-green-light {
            filter: drop-shadow(0 0 6px rgba(144, 238, 144, 0.9)) drop-shadow(0 0 12px rgba(144, 238, 144, 0.5)); /* lightgreen */
        }
        .glow-green-yellow {
            filter: drop-shadow(0 0 6px rgba(173, 255, 47, 0.9)) drop-shadow(0 0 12px rgba(173, 255, 47, 0.55)); /* greenyellow */
        }
        .glow-yellow {
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 12px rgba(255, 215, 0, 0.55)); /* gold */
        }
        .glow-orange {
            filter: drop-shadow(0 0 6px rgba(255, 140, 0, 0.95)) drop-shadow(0 0 12px rgba(255, 140, 0, 0.55)); /* darkorange */
        }
        .glow-red {
            filter: drop-shadow(0 0 6px rgba(220, 20, 60, 0.95)) drop-shadow(0 0 12px rgba(220, 20, 60, 0.6)); /* crimson */
        }
        
        .market-marker {
            background: #ff6b6b;
            border: 3px solid #c92a2a;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="brand">
            <img class="logo" src="{{ url_for('static', filename='images/logo.png') }}" alt="Brew View Logo" />
            <h1>Brew View</h1>
        </div>
        <p>Potion Flow Monitoring Dashboard</p>
    </div>
    
    <!-- Tabs Navigation -->
    <div class="tabs">
        <button class="tab active" onclick="switchTab('map', this)">üìç Map</button>
        <button class="tab" onclick="switchTab('tickets', this)">üé´ Ticket Logs</button>
    </div>
    
    <!-- Map Tab Content -->
    <div id="map-tab" class="tab-content active">
        <div class="container">
            <div class="map-container">
                <h2>üìç Cauldron Network Map</h2>
                <div id="loading" class="loading">Loading cauldron data...</div>
                <div id="map"></div>
            </div>
        
        <div class="timeline-container">
            <h2>‚è±Ô∏è Historical Timeline</h2>
            
            <!-- Date and Time Selection Row -->
            <div class="slider-row">
                <!-- Date Selectors on the left -->
                <div class="date-selector">
                    <div class="date-group">
                        <label for="year-select">Year</label>
                        <select id="year-select">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="month-select">Month</label>
                        <select id="month-select">
                            <option value="">Select year first</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="day-select">Day</label>
                        <select id="day-select">
                            <option value="">Select month first</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="timezone-select">Timezone</label>
                        <select id="timezone-select">
                            <option value="UTC">UTC</option>
                            <option value="America/New_York">Eastern (ET)</option>
                            <option value="America/Chicago">Central (CT)</option>
                            <option value="America/Denver">Mountain (MT)</option>
                            <option value="America/Los_Angeles">Pacific (PT)</option>
                            <option value="America/Phoenix">Arizona (MST)</option>
                            <option value="America/Anchorage">Alaska (AKT)</option>
                            <option value="Pacific/Honolulu">Hawaii (HST)</option>
                            <option value="Europe/London">London (GMT/BST)</option>
                            <option value="Europe/Paris">Paris (CET)</option>
                            <option value="Asia/Tokyo">Tokyo (JST)</option>
                            <option value="Asia/Shanghai">Shanghai (CST)</option>
                            <option value="Australia/Sydney">Sydney (AEDT)</option>
                        </select>
                    </div>
                </div>
                
                <!-- Time Slider on the right -->
                <div class="slider-section">
                    <div class="time-label">Time of Day:</div>
                    <div class="timeline-info">
                        <div>
                            <span class="timestamp-display" id="current-timestamp">Select a date...</span>
                        </div>
                    </div>
                    <input type="range" class="timeline-slider" id="time-slider" 
                           min="0" max="0" value="0" step="1" disabled>
                    
                    <!-- Playback Controls centered underneath timeline -->
                    <div class="timeline-controls">
                        <button class="timeline-btn" id="btn-first">‚èÆÔ∏è First</button>
                        <button class="timeline-btn" id="btn-prev">‚è™ Previous</button>
                        <button class="timeline-btn" id="btn-play">‚ñ∂Ô∏è Play</button>
                        <button class="timeline-btn" id="btn-next">Next ‚è©</button>
                        <button class="timeline-btn" id="btn-last">‚è≠Ô∏è Last</button>
                    </div>
                </div>
            </div>
            
            <!-- Show Button -->
            <div class="show-btn-container">
                <button class="timeline-btn show-btn" id="btn-show">üîç Show</button>
            </div>
        </div>
        
        <div class="info-panel">
            <h2>üìä Network Statistics</h2>
            <div class="stats" id="stats">
                <!-- Stats will be populated by JavaScript -->
            </div>
        </div>
        </div>
    </div>
    
    <!-- Ticket Logs Tab Content -->
    <div id="tickets-tab" class="tab-content">
        <div class="container">
            <div class="info-panel">
                <h2>üé´ Ticket Logs</h2>
                <div id="ticket-loading" class="loading">Loading tickets...</div>
                <div id="ticket-container" style="display: none;">
                    <!-- Statistics Panel -->
                    <div id="ticket-stats" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Filters and Sorting -->
                    <div class="ticket-filters">
                        <div class="filter-group">
                            <label for="sort-by">Sort By:</label>
                            <select id="sort-by" onchange="applyFiltersAndSort()">
                                <option value="date-desc">Date (Newest First)</option>
                                <option value="date-asc">Date (Oldest First)</option>
                                <option value="amount-desc">Amount (High to Low)</option>
                                <option value="amount-asc">Amount (Low to High)</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Cauldrons:</label>
                            <div class="dropdown-filter" id="cauldron-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('cauldron-dropdown')">
                                    <span id="cauldron-dropdown-label">All Cauldrons</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-cauldron-container"><!-- populated dynamically --></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <label>Couriers:</label>
                            <div class="dropdown-filter" id="courier-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('courier-dropdown')">
                                    <span id="courier-dropdown-label">All Couriers</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-courier-container"><!-- populated dynamically --></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <label for="filter-date">Date:</label>
                            <input type="date" id="filter-date" onchange="applyFiltersAndSort()">
                        </div>
                        
                        <div class="filter-group">
                            <label>Status:</label>
                            <div class="dropdown-filter" id="status-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('status-dropdown')">
                                    <span id="status-dropdown-label">All Statuses</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-status-container">
                                        <div class="checkbox-item">
                                            <input type="checkbox" id="status-normal" value="normal" checked onchange="applyFiltersAndSort();updateDropdownLabels()">
                                            <label for="status-normal">Normal</label>
                                        </div>
                                        <div class="checkbox-item">
                                            <input type="checkbox" id="status-suspicious" value="suspicious" checked onchange="applyFiltersAndSort();updateDropdownLabels()">
                                            <label for="status-suspicious">Suspicious</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <button onclick="resetFilters()">Reset Filters</button>
                        </div>
                    </div>
                    
                    <table class="ticket-table" id="ticket-table">
                        <thead>
                            <tr>
                                <th>Ticket ID</th>
                                <th>Cauldron</th>
                                <th>Amount Collected</th>
                                <th>Courier</th>
                                <th>Date</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="ticket-tbody">
                            <!-- Tickets will be populated here -->
                        </tbody>
                    </table>
                    <div class="pagination">
                        <button id="ticket-prev" onclick="changeTicketPage(-1)">‚è™ Previous</button>
                        <span id="ticket-page-info">Page 1 of 1</span>
                        <button id="ticket-next" onclick="changeTicketPage(1)">Next ‚è©</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Tab switching function
        function switchTab(tabName, element) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Add active class to clicked tab
            if (element) {
                element.classList.add('active');
            }
            
            // If switching to map tab, invalidate size to fix rendering issues
            if (tabName === 'map' && map) {
                setTimeout(() => map.invalidateSize(), 100);
            }
        }

        // Build a cauldron icon using PNG with a color glow based on fill percent
        function getCauldronIcon(fillPercent) {
            let glowClass = 'glow-green-light';
            const p = typeof fillPercent === 'number' ? fillPercent : parseFloat(fillPercent) || 0;
            if (p > 90) glowClass = 'glow-red';
            else if (p > 75) glowClass = 'glow-orange';
            else if (p > 60) glowClass = 'glow-yellow';
            else if (p > 40) glowClass = 'glow-green-yellow';

            const imgSrc = "{{ url_for('static', filename='images/markers/cauldron.png') }}";
            const html = `<div class="cauldron-img-wrapper ${glowClass}"><img class="cauldron-img" src="${imgSrc}" alt="Cauldron" /></div>`;
            return L.divIcon({
                className: 'custom-icon',
                html,
                iconSize: [36, 36],
                iconAnchor: [18, 18]
            });
        }

        // Dropdown checkbox helpers
        function toggleFilterDropdown(id) {
            const dd = document.getElementById(id);
            const isOpen = dd.classList.contains('open');
            // Close all first
            document.querySelectorAll('.dropdown-filter.open').forEach(el => el.classList.remove('open'));
            if (!isOpen) dd.classList.add('open');
        }

        // Close dropdowns on outside click
        document.addEventListener('click', (e) => {
            const anyDropdown = e.target.closest('.dropdown-filter');
            const anyToggle = e.target.closest('.dropdown-filter-toggle');
            if (!anyDropdown && !anyToggle) {
                document.querySelectorAll('.dropdown-filter.open').forEach(el => el.classList.remove('open'));
            }
        });

        // Removed search and select-all/none per updated requirements

        function updateDropdownLabels() {
            // Cauldrons
            const cbsC = Array.from(document.querySelectorAll('#filter-cauldron-container input[type="checkbox"]'));
            const selectedC = cbsC.filter(cb => cb.checked).map(cb => cb.value);
            const cLabel = document.getElementById('cauldron-dropdown-label');
            cLabel.textContent = selectedC.length === cbsC.length ? 'All Cauldrons' : (selectedC.slice(0,3).join(', ') + (selectedC.length>3 ? ` +${selectedC.length-3}` : '')) || 'None';

            // Couriers
            const cbsR = Array.from(document.querySelectorAll('#filter-courier-container input[type="checkbox"]'));
            const selectedR = cbsR.filter(cb => cb.checked).map(cb => cb.value);
            const rLabel = document.getElementById('courier-dropdown-label');
            rLabel.textContent = selectedR.length === cbsR.length ? 'All Couriers' : (selectedR.slice(0,3).join(', ') + (selectedR.length>3 ? ` +${selectedR.length-3}` : '')) || 'None';

            // Status
            const cbsS = Array.from(document.querySelectorAll('#filter-status-container input[type="checkbox"]'));
            const selectedS = cbsS.filter(cb => cb.checked).map(cb => cb.value);
            const sLabel = document.getElementById('status-dropdown-label');
            const pretty = { normal: 'Normal', suspicious: 'Suspicious' };
            sLabel.textContent = selectedS.length === cbsS.length ? 'All Statuses' : (selectedS.map(v => pretty[v] || v).join(', ') || 'None');
        }
        
        let map;
        let cauldrons = [];
        let market = null;
        let network = [];
        let currentLevels = {};
        let cauldronMarkers = {};
        let allTimestamps = [];
        let filteredTimestamps = [];
        let timestampIndices = [];
        let currentIndex = 0;
        let isPlaying = false;
        let playInterval = null;
        let dateGroups = {};
        let cachedData = null; // Cache all historical data
        let isDataLoaded = false;
        let selectedTimezone = 'UTC'; // Default timezone
        
        // Ticket pagination
        let allTickets = [];
        let filteredTickets = [];
        let currentTicketPage = 1;
        let ticketsPerPage = 10;
        
        // Initialize map
        function initMap() {
            // Default center (will be updated when data loads)
            map = L.map('map').setView([33.2148, -97.13], 13);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Fetch current potion levels
        async function loadCurrentLevels() {
            try {
                const response = await fetch('/api/current-levels');
                const data = await response.json();
                
                if (data.error) {
                    console.warn('Could not load current levels:', data.error);
                    return;
                }
                
                currentLevels = data.levels || {};
                console.log('Loaded current levels:', currentLevels);
            } catch (error) {
                console.error('Error loading current levels:', error);
            }
        }
        
        // Load all historical data at once for client-side caching
        async function loadAllHistoricalData() {
            if (isDataLoaded && cachedData) {
                console.log('Using cached data');
                return true;
            }
            
            try {
                console.log('Loading full historical data... (this may take a moment)');
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Loading historical data...';
                
                const response = await fetch('/api/data-full', {
                    cache: 'force-cache' // Use browser cache if available
                });
                const result = await response.json();
                
                if (result.error) {
                    console.error('Could not load historical data:', result.error);
                    return false;
                }
                
                cachedData = result.data || [];
                console.log('Loaded and cached', cachedData.length, 'timestamps');
                
                // Extract timestamps for organization
                allTimestamps = cachedData.map(record => record.timestamp);
                
                // Organize timestamps by date
                organizeDateGroups();
                populateDateDropdowns();
                
                isDataLoaded = true;
                document.getElementById('loading').style.display = 'none';
                
                return true;
            } catch (error) {
                console.error('Error loading historical data:', error);
                document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                return false;
            }
        }
        
        // Load timestamps (deprecated - now using loadAllHistoricalData)
        async function loadTimestamps() {
            return await loadAllHistoricalData();
        }
        
        // Organize timestamps into year/month/day groups
        function organizeDateGroups() {
            dateGroups = {};
            
            allTimestamps.forEach((timestamp, index) => {
                const date = new Date(timestamp);
                let year, month, day;
                
                if (selectedTimezone === 'UTC') {
                    // Use UTC
                    year = date.getUTCFullYear();
                    month = date.getUTCMonth() + 1; // 1-12
                    day = date.getUTCDate();
                } else {
                    // Convert to selected timezone
                    const dateStr = date.toLocaleString('en-US', { 
                        timeZone: selectedTimezone,
                        year: 'numeric',
                        month: 'numeric',
                        day: 'numeric'
                    });
                    const parts = dateStr.split('/');
                    month = parseInt(parts[0]);
                    day = parseInt(parts[1]);
                    year = parseInt(parts[2]);
                }
                
                if (!dateGroups[year]) dateGroups[year] = {};
                if (!dateGroups[year][month]) dateGroups[year][month] = {};
                if (!dateGroups[year][month][day]) dateGroups[year][month][day] = [];
                
                dateGroups[year][month][day].push({
                    timestamp: timestamp,
                    index: index
                });
            });
            
            // Debug: Log sample day to verify all 24 hours
            const sampleYear = Object.keys(dateGroups)[0];
            if (sampleYear) {
                const sampleMonth = Object.keys(dateGroups[sampleYear])[0];
                const sampleDay = Object.keys(dateGroups[sampleYear][sampleMonth])[0];
                const dayTimestamps = dateGroups[sampleYear][sampleMonth][sampleDay];
                console.log(`Sample day ${sampleYear}-${sampleMonth}-${sampleDay} (${selectedTimezone}) has ${dayTimestamps.length} timestamps`);
                if (dayTimestamps.length > 0) {
                    console.log('First:', dayTimestamps[0].timestamp);
                    console.log('Last:', dayTimestamps[dayTimestamps.length - 1].timestamp);
                }
            }
        }
        
        // Populate year/month/day dropdowns
        function populateDateDropdowns() {
            const yearSelect = document.getElementById('year-select');
            const years = Object.keys(dateGroups).sort((a, b) => b - a);
            
            yearSelect.innerHTML = '<option value="">Select a year</option>';
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            });
            
            // Select most recent year by default
            if (years.length > 0) {
                yearSelect.value = years[0];
                updateMonthDropdown(years[0]);
            }
        }
        
        // Update month dropdown based on selected year
        function updateMonthDropdown(year) {
            const monthSelect = document.getElementById('month-select');
            const monthNames = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthSelect.innerHTML = '<option value="">Select a month</option>';
            
            if (!year || !dateGroups[year]) return;
            
            const months = Object.keys(dateGroups[year]).sort((a, b) => b - a);
            months.forEach(month => {
                const option = document.createElement('option');
                option.value = month;
                option.textContent = monthNames[parseInt(month)];
                monthSelect.appendChild(option);
            });
            
            // Select most recent month by default
            if (months.length > 0) {
                monthSelect.value = months[0];
                updateDayDropdown(year, months[0]);
            }
        }
        
        // Update day dropdown based on selected year and month
        function updateDayDropdown(year, month) {
            const daySelect = document.getElementById('day-select');
            
            daySelect.innerHTML = '<option value="">Select a day</option>';
            
            if (!year || !month || !dateGroups[year] || !dateGroups[year][month]) return;
            
            const days = Object.keys(dateGroups[year][month]).sort((a, b) => b - a);
            days.forEach(day => {
                const option = document.createElement('option');
                option.value = day;
                option.textContent = day;
                daySelect.appendChild(option);
            });
            
            // Select most recent day by default
            if (days.length > 0) {
                daySelect.value = days[0];
            }
        }
        
        // Filter timestamps for selected date
        function filterTimestampsForDate(year, month, day) {
            if (!year || !month || !day || !dateGroups[year] || !dateGroups[year][month] || !dateGroups[year][month][day]) {
                return [];
            }
            
            return dateGroups[year][month][day];
        }
        
        // Update time slider for selected date
        function updateTimeSlider() {
            const year = document.getElementById('year-select').value;
            const month = document.getElementById('month-select').value;
            const day = document.getElementById('day-select').value;
            
            const dayData = filterTimestampsForDate(year, month, day);
            filteredTimestamps = dayData;
            
            const slider = document.getElementById('time-slider');
            slider.max = dayData.length - 1;
            slider.value = dayData.length - 1;
            slider.disabled = dayData.length === 0;
            
            if (dayData.length > 0) {
                currentIndex = dayData.length - 1;
                updateTimestampDisplay();
            }
        }
        
        // Show data for selected date/time
        async function showSelectedData() {
            const year = document.getElementById('year-select').value;
            const month = document.getElementById('month-select').value;
            const day = document.getElementById('day-select').value;
            
            if (!year || !month || !day) {
                alert('Please select a year, month, and day');
                return;
            }
            
            updateTimeSlider();
            
            if (filteredTimestamps.length > 0) {
                const sliderIndex = parseInt(document.getElementById('time-slider').value);
                const actualIndex = filteredTimestamps[sliderIndex].index;
                await loadLevelsAtIndex(actualIndex);
            }
        }
        
        // Load levels at specific index (original function remains the same)
        // Load levels at specific index (now using cached data)
        function loadLevelsAtIndex(index) {
            try {
                // Use cached data instead of API call
                if (!cachedData || index < 0 || index >= cachedData.length) {
                    console.error('Invalid index or data not loaded:', index);
                    return false;
                }
                
                const record = cachedData[index];
                currentLevels = record.cauldron_levels || {};
                
                updateCauldronMarkers();
                updateStats();
                
                return true;
            } catch (error) {
                console.error('Error loading levels at index:', error);
                return false;
            }
        }
        
        // Update timestamp display
        function updateTimestampDisplay() {
            if (!filteredTimestamps || filteredTimestamps.length === 0) return;
            
            const sliderIndex = parseInt(document.getElementById('time-slider').value);
            if (sliderIndex < 0 || sliderIndex >= filteredTimestamps.length) return;
            
            const timestamp = filteredTimestamps[sliderIndex].timestamp;
            const date = new Date(timestamp);
            
            const options = {
                month: 'short', 
                day: 'numeric', 
                year: 'numeric',
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit',
                timeZone: selectedTimezone,
                timeZoneName: 'short'
            };
            
            document.getElementById('current-timestamp').textContent = 
                date.toLocaleString('en-US', options);
        }
        
        // Update cauldron markers with new data
        function updateCauldronMarkers() {
            cauldrons.forEach(cauldron => {
                const marker = cauldronMarkers[cauldron.id];
                if (!marker) return;
                
                const maxVolume = cauldron.max_volume || 1000;
                const currentVolume = currentLevels[cauldron.id] || 0;
                const fillPercent = ((currentVolume / maxVolume) * 100).toFixed(1);
                const name = cauldron.name || cauldron.id;
                
                // Update marker icon using PNG with glow
                const icon = getCauldronIcon(parseFloat(fillPercent));
                marker.setIcon(icon);
                
                // Update popup
                marker.setPopupContent(`
                    <b>${name}</b><br>
                    ID: ${cauldron.id}<br>
                    <b>Current: ${currentVolume.toFixed(1)}L / ${maxVolume}L</b><br>
                    <b>Fill Level: ${fillPercent}%</b><br>
                    Location: ${cauldron.latitude.toFixed(4)}, ${cauldron.longitude.toFixed(4)}
                `);
                
                // Update tooltip
                marker.setTooltipContent(`${name}<br>${fillPercent}%`);
            });
        }
        
        // Fetch current potion levels (original function - now used for initial load)
        async function loadInitialCurrentLevels() {
            try {
                const response = await fetch('/api/current-levels');
                const data = await response.json();
                
                if (data.error) {
                    console.warn('Could not load current levels:', data.error);
                    return;
                }
                
                currentLevels = data.levels || {};
                console.log('Loaded current levels:', currentLevels);
            } catch (error) {
                console.error('Error loading current levels:', error);
            }
        }
        
        // Fetch and display cauldrons
        async function loadCauldrons() {
            try {
                const response = await fetch('/api/cauldrons');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                cauldrons = data;
                console.log('Loaded cauldrons:', cauldrons);
                
                // Add cauldron markers (will be updated by timeline)
                cauldrons.forEach(cauldron => {
                    const lat = cauldron.latitude;
                    const lon = cauldron.longitude;
                    const name = cauldron.name || cauldron.id;
                    const maxVolume = cauldron.max_volume || 1000;
                    
                    // Start with default icon
                    const currentVolume = 0;
                    const fillPercent = 0;
                    
                    // Determine color based on fill level
                    let markerColor = 'üß™'; // Default blue
                    if (fillPercent > 90) {
                        markerColor = 'üî¥'; // Red - almost full
                    } else if (fillPercent > 70) {
                        markerColor = 'üü†'; // Orange - getting full
                    } else if (fillPercent > 50) {
                        markerColor = 'üü°'; // Yellow - half full
                    } else {
                        markerColor = 'üîµ'; // Blue - plenty of space
                    }
                    
                    // Create PNG icon with default (blue) glow
                    const icon = getCauldronIcon(fillPercent);
                    
                    // Add marker
                    const marker = L.marker([lat, lon], { icon: icon }).addTo(map);
                    
                    // Store marker reference
                    cauldronMarkers[cauldron.id] = marker;
                    
                    // Add popup with current level info
                    marker.bindPopup(`
                        <b>${name}</b><br>
                        ID: ${cauldron.id}<br>
                        <b>Current: ${currentVolume.toFixed(1)}L / ${maxVolume}L</b><br>
                        <b>Fill Level: ${fillPercent}%</b><br>
                        Location: ${lat.toFixed(4)}, ${lon.toFixed(4)}
                    `);
                    
                    // Add permanent label with fill percentage
                    marker.bindTooltip(`${name}<br>${fillPercent}%`, {
                        permanent: true,
                        direction: 'top',
                        className: 'cauldron-label',
                        offset: [0, -15]
                    });
                });
                
                return true;
            } catch (error) {
                console.error('Error loading cauldrons:', error);
                document.getElementById('loading').innerHTML = 
                    `<div class="error">Error loading cauldrons: ${error.message}</div>`;
                return false;
            }
        }
        
        // Fetch and display market
        async function loadMarket() {
            try {
                const response = await fetch('/api/market');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                market = data;
                console.log('Loaded market:', market);
                
                const lat = market.latitude;
                const lon = market.longitude;
                const name = market.name || 'Enchanted Market';
                
                // Create custom market icon using PNG
                const icon = L.icon({
                    iconUrl: '/static/images/markers/market.png',
                    iconSize: [50, 50],
                    iconAnchor: [25, 25],
                    popupAnchor: [0, -25]
                });
                
                // Add marker
                const marker = L.marker([lat, lon], { icon: icon }).addTo(map);
                
                // Add popup
                marker.bindPopup(`
                    <b>${name}</b><br>
                    ID: ${market.id}<br>
                    Central Trading Hub<br>
                    Location: ${lat.toFixed(4)}, ${lon.toFixed(4)}
                `);
                
                // Add permanent label
                marker.bindTooltip(name, {
                    permanent: true,
                    direction: 'top',
                    className: 'market-label',
                    offset: [0, -20]
                });
                
                return true;
            } catch (error) {
                console.error('Error loading market:', error);
                return false;
            }
        }
        
        // Fetch and display network connections
        async function loadNetwork() {
            try {
                const response = await fetch('/api/network');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                network = data.edges || data;
                console.log('Loaded network:', network);
                
                // We'll need cauldron and market coordinates to draw lines
                const coords = {};
                
                // Map cauldron IDs to coordinates
                cauldrons.forEach(c => {
                    coords[c.id] = [c.latitude, c.longitude];
                });
                
                // Add market coordinates
                if (market) {
                    coords[market.id] = [market.latitude, market.longitude];
                    coords['MARKET'] = [market.latitude, market.longitude];
                    coords['market_001'] = [market.latitude, market.longitude];
                }
                
                // Draw connections
                network.forEach(edge => {
                    const fromCoords = coords[edge.from];
                    const toCoords = coords[edge.to];
                    
                    if (fromCoords && toCoords) {
                        const isMarketConnection = 
                            edge.from === 'MARKET' || edge.from === market?.id ||
                            edge.to === 'MARKET' || edge.to === market?.id;
                        
                        L.polyline([fromCoords, toCoords], {
                            color: isMarketConnection ? '#ff6b6b' : '#667eea',
                            weight: 2,
                            opacity: 0.6
                        }).addTo(map).bindPopup(`
                            ${edge.from} ‚Üí ${edge.to}<br>
                            Travel Time: ${edge.travel_time_minutes || edge.travel_time || '?'} min
                        `);
                    }
                });
                
                return true;
            } catch (error) {
                console.error('Error loading network:', error);
                return false;
            }
        }
        
        // Update statistics
        function updateStats() {
            const totalCapacity = cauldrons.reduce((sum, c) => sum + (c.max_volume || 1000), 0);
            const totalCurrent = Object.values(currentLevels).reduce((sum, level) => sum + level, 0);
            const avgFillPercent = totalCapacity > 0 ? ((totalCurrent / totalCapacity) * 100).toFixed(1) : 0;
            
            const statsHtml = `
                <div class="stat-card">
                    <h3>${cauldrons.length}</h3>
                    <p>Total Cauldrons</p>
                </div>
                <div class="stat-card">
                    <h3>${totalCurrent.toFixed(0)}L</h3>
                    <p>Current Total Volume</p>
                </div>
                <div class="stat-card">
                    <h3>${avgFillPercent}%</h3>
                    <p>Average Fill Level</p>
                </div>
                <div class="stat-card">
                    <h3>${network.length}</h3>
                    <p>Network Connections</p>
                </div>
                <div class="stat-card">
                    <h3>${totalCapacity}L</h3>
                    <p>Total Capacity</p>
                </div>
            `;
            document.getElementById('stats').innerHTML = statsHtml;
        }
        
        // Center map on all markers
        function centerMap() {
            const bounds = [];
            
            cauldrons.forEach(c => {
                bounds.push([c.latitude, c.longitude]);
            });
            
            if (market) {
                bounds.push([market.latitude, market.longitude]);
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Timeline control functions
        function setupTimelineControls() {
            const slider = document.getElementById('time-slider');
            const btnShow = document.getElementById('btn-show');
            const btnFirst = document.getElementById('btn-first');
            const btnPrev = document.getElementById('btn-prev');
            const btnPlay = document.getElementById('btn-play');
            const btnNext = document.getElementById('btn-next');
            const btnLast = document.getElementById('btn-last');
            const yearSelect = document.getElementById('year-select');
            const monthSelect = document.getElementById('month-select');
            const daySelect = document.getElementById('day-select');
            const timezoneSelect = document.getElementById('timezone-select');
            
            // Timezone change - reorganize all data
            timezoneSelect.addEventListener('change', function() {
                selectedTimezone = this.value;
                console.log('Timezone changed to:', selectedTimezone);
                
                // Reorganize date groups with new timezone
                organizeDateGroups();
                populateDateDropdowns();
                
                // Update display if a date is selected
                if (filteredTimestamps.length > 0) {
                    updateTimestampDisplay();
                }
            });
            
            // Date dropdown changes
            yearSelect.addEventListener('change', function() {
                updateMonthDropdown(this.value);
            });
            
            monthSelect.addEventListener('change', function() {
                const year = yearSelect.value;
                updateDayDropdown(year, this.value);
            });
            
            // Show button
            btnShow.addEventListener('click', showSelectedData);
            
            // Time slider change
            slider.addEventListener('input', function() {
                updateTimestampDisplay();
            });
            
            slider.addEventListener('change', async function() {
                if (filteredTimestamps.length > 0) {
                    const sliderIndex = parseInt(this.value);
                    const actualIndex = filteredTimestamps[sliderIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                }
            });
            
            // First button
            btnFirst.addEventListener('click', async function() {
                if (filteredTimestamps.length > 0) {
                    slider.value = 0;
                    const actualIndex = filteredTimestamps[0].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Previous button
            btnPrev.addEventListener('click', async function() {
                const sliderIndex = parseInt(slider.value);
                const newIndex = Math.max(0, sliderIndex - 1);
                slider.value = newIndex;
                if (filteredTimestamps.length > 0) {
                    const actualIndex = filteredTimestamps[newIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Play/Pause button
            btnPlay.addEventListener('click', function() {
                if (isPlaying) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
            });
            
            // Next button
            btnNext.addEventListener('click', async function() {
                const sliderIndex = parseInt(slider.value);
                const newIndex = Math.min(filteredTimestamps.length - 1, sliderIndex + 1);
                slider.value = newIndex;
                if (filteredTimestamps.length > 0) {
                    const actualIndex = filteredTimestamps[newIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Last button
            btnLast.addEventListener('click', async function() {
                if (filteredTimestamps.length > 0) {
                    slider.value = filteredTimestamps.length - 1;
                    const actualIndex = filteredTimestamps[filteredTimestamps.length - 1].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
        }
        
        function startPlayback() {
            if (filteredTimestamps.length === 0) return;
            
            isPlaying = true;
            document.getElementById('btn-play').textContent = '‚è∏Ô∏è Pause';
            
            const slider = document.getElementById('time-slider');
            
            playInterval = setInterval(async () => {
                const sliderIndex = parseInt(slider.value);
                if (sliderIndex >= filteredTimestamps.length - 1) {
                    stopPlayback();
                    return;
                }
                
                const newIndex = sliderIndex + 1;
                slider.value = newIndex;
                const actualIndex = filteredTimestamps[newIndex].index;
                await loadLevelsAtIndex(actualIndex);
                updateTimestampDisplay();
            }, 100); // Play at 10 timestamps per second (100ms each)
        }
        
        function stopPlayback() {
            isPlaying = false;
            document.getElementById('btn-play').textContent = '‚ñ∂Ô∏è Play';
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }
        
        // Load tickets from API
        async function loadTickets() {
            try {
                const response = await fetch('/api/tickets');
                const data = await response.json();
                
                if (data.error) {
                    console.error('Could not load tickets:', data.error);
                    document.getElementById('ticket-loading').textContent = 'Error loading tickets';
                    return false;
                }
                
                // API returns {metadata, transport_tickets}
                allTickets = data.transport_tickets || [];
                filteredTickets = [...allTickets]; // Initialize filtered tickets
                
                console.log('Loaded', allTickets.length, 'tickets');
                console.log('Metadata:', data.metadata);
                console.log('Sample ticket:', allTickets[0]);
                
                populateFilterDropdowns();
                // If historical data already loaded compute discrepancies now
                if (cachedData && cachedData.length) {
                    computeDailyDrainEvents();
                    annotateTicketDiscrepancies();
                }
                displayTickets();
                document.getElementById('ticket-loading').style.display = 'none';
                document.getElementById('ticket-container').style.display = 'block';
                
                return true;
            } catch (error) {
                console.error('Error loading tickets:', error);
                document.getElementById('ticket-loading').textContent = 'Error loading tickets';
                return false;
            }
        }

        // Map: date -> cauldron_id -> [drain events]
        let dailyDrainEvents = {};
        // Map: cauldron_id -> estimated fill_rate (L/min) calculated from data
        let cauldronFillRates = {};

        // Step 1: Estimate fill rates from historical data by analyzing positive deltas
        // Only use data from stable generation periods (not during drains)
        function estimateFillRates() {
            cauldronFillRates = {};
            if (!cachedData || cachedData.length < 2) return;
            
            const deltasByCauldron = {}; // cauldron_id -> [positive deltas during generation]
            
            // First pass: identify drain periods (consecutive negative deltas)
            const isDraining = {}; // index -> cauldron_id -> boolean
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                
                if (!isDraining[i]) isDraining[i] = {};
                if (!isDraining[i-1]) isDraining[i-1] = {};
                
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    
                    // Mark as draining if negative delta
                    if (delta < -0.1) {
                        isDraining[i][id] = true;
                        isDraining[i-1][id] = true; // Mark previous point too
                        // Also mark next few points to avoid drain tail effects
                        if (isDraining[i+1]) isDraining[i+1][id] = true;
                        if (isDraining[i+2]) isDraining[i+2][id] = true;
                    }
                });
            }
            
            // Second pass: collect positive deltas ONLY from non-drain periods
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    
                    // Only collect positive deltas when NOT draining
                    if (delta > 0 && !isDraining[i]?.[id] && !isDraining[i-1]?.[id]) {
                        if (!deltasByCauldron[id]) deltasByCauldron[id] = [];
                        deltasByCauldron[id].push(delta);
                    }
                });
            }
            
            // Calculate average (mean) positive delta as fill_rate estimate (L/min)
            // Using mean instead of median for more stable rate estimation
            Object.keys(deltasByCauldron).forEach(id => {
                const deltas = deltasByCauldron[id];
                if (deltas.length === 0) {
                    cauldronFillRates[id] = 1.0; // Fallback
                    return;
                }
                const sum = deltas.reduce((acc, val) => acc + val, 0);
                const mean = sum / deltas.length;
                cauldronFillRates[id] = mean;
            });
            
            console.log('Estimated fill rates (L/min) from non-drain periods:', cauldronFillRates);
            Object.keys(cauldronFillRates).forEach(id => {
                const rate = cauldronFillRates[id];
                const sampleCount = deltasByCauldron[id]?.length || 0;
                console.log(`  ${id}: ${rate.toFixed(3)} L/min (${sampleCount} samples)`);
            });
        }

        // Step 2: Detect individual drain events and store them
        // Each drain event = one pickup session (~15 minutes of continuous decline)
        function computeDailyDrainEvents() {
            dailyDrainEvents = {};
            if (!cachedData || !cachedData.length) return;
            
            // First estimate fill rates from the data
            estimateFillRates();
            
            const DRAIN_DURATION_MIN = 15;
            
            // Group data by date and cauldron
            const seriesByDateCauldron = {}; // date -> cauldron -> [{timestamp, level, delta}]
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                const dateStr = new Date(curr.timestamp).toISOString().slice(0,10);
                if (!seriesByDateCauldron[dateStr]) seriesByDateCauldron[dateStr] = {};
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    if (!seriesByDateCauldron[dateStr][id]) seriesByDateCauldron[dateStr][id] = [];
                    seriesByDateCauldron[dateStr][id].push({timestamp: curr.timestamp, level: Vcurr, prevLevel: Vprev, delta});
                });
            }
            
            // Detect individual drain events (sessions): continuous negative deltas
            Object.keys(seriesByDateCauldron).forEach(dateStr => {
                if (!dailyDrainEvents[dateStr]) dailyDrainEvents[dateStr] = {};
                Object.keys(seriesByDateCauldron[dateStr]).forEach(id => {
                    const series = seriesByDateCauldron[dateStr][id];
                    let sessionStart = null;
                    let sessionStartLevel = 0;
                    let sessionEndLevel = 0;
                    let sessionStartTime = null;
                    const events = [];
                    
                    for (let i = 0; i < series.length; i++) {
                        const pt = series[i];
                        if (pt.delta < -0.1) { // Negative delta = drain (use threshold to avoid noise)
                            // Drain detected
                            if (sessionStart === null) {
                                // Start new drain session
                                sessionStart = i;
                                sessionStartLevel = pt.prevLevel; // Level before drain started
                                sessionStartTime = pt.timestamp;
                            }
                            sessionEndLevel = pt.level; // Current level
                        } else {
                            // Not draining - close session if one was active
                            if (sessionStart !== null) {
                                // Session ended - calculate VTrue for this drain event
                                const fillRate = cauldronFillRates[id] ?? 1.0;
                                const drainedRaw = sessionStartLevel - sessionEndLevel;
                                // VTrue = raw drain + generation during drain (fill_rate √ó 15 min)
                                const VTrue = drainedRaw + (fillRate * DRAIN_DURATION_MIN);
                                events.push({
                                    startTime: sessionStartTime,
                                    startLevel: sessionStartLevel,
                                    endLevel: sessionEndLevel,
                                    drainedRaw: drainedRaw,
                                    VTrue: VTrue,
                                    fillRate: fillRate,
                                    matched: false,
                                    matchedTicket: null
                                });
                                sessionStart = null;
                            }
                        }
                    }
                    // Close last session if still active at end of day
                    if (sessionStart !== null) {
                        const fillRate = cauldronFillRates[id] ?? 1.0;
                        const drainedRaw = sessionStartLevel - sessionEndLevel;
                        const VTrue = drainedRaw + (fillRate * DRAIN_DURATION_MIN);
                        events.push({
                            startTime: sessionStartTime,
                            startLevel: sessionStartLevel,
                            endLevel: sessionEndLevel,
                            drainedRaw: drainedRaw,
                            VTrue: VTrue,
                            fillRate: fillRate,
                            matched: false,
                            matchedTicket: null
                        });
                    }
                    
                    if (events.length > 0) {
                        dailyDrainEvents[dateStr][id] = events;
                    }
                });
            });
            console.log('Detected individual drain events per day/cauldron:', dailyDrainEvents);
        }

        // Match tickets to drain events and annotate with discrepancy status
        function annotateTicketDiscrepancies() {
            if (!allTickets || !allTickets.length) return;
            const TOLERANCE = 0.20; // 20% tolerance to account for measurement noise and timing differences
            
            console.log('=== TICKET-TO-DRAIN MATCHING ===');
            
            // Track discrepancy distribution for analysis
            const discrepancies = [];
            let totalTickets = 0;
            let matchCount = 0;
            let overCount = 0;
            let underCount = 0;
            let noDataCount = 0;
            let unmatchedCount = 0;
            
            // Group tickets by date and cauldron
            const ticketsByDateCauldron = {};
            allTickets.forEach(t => {
                // Normalize date format to YYYY-MM-DD
                let normalizedDate = t.date;
                if (normalizedDate && normalizedDate.includes('T')) {
                    // If date has time component, extract just the date part
                    normalizedDate = normalizedDate.slice(0, 10);
                }
                const key = `${normalizedDate}|${t.cauldron_id}`;
                if (!ticketsByDateCauldron[key]) ticketsByDateCauldron[key] = [];
                ticketsByDateCauldron[key].push(t);
            });
            
            console.log('Ticket date/cauldron keys:', Object.keys(ticketsByDateCauldron).slice(0, 10));
            console.log('Drain event dates:', Object.keys(dailyDrainEvents));
            
            // For each date/cauldron combo, match tickets to drain events
            Object.keys(ticketsByDateCauldron).forEach(key => {
                const [date, cauldronId] = key.split('|');
                const tickets = ticketsByDateCauldron[key];
                const drainEvents = dailyDrainEvents?.[date]?.[cauldronId] || [];
                
                if (drainEvents.length === 0) {
                    // No drain data - mark all tickets as no-data
                    console.log(`‚ö†Ô∏è No drain events found for ${date} | ${cauldronId} (${tickets.length} tickets)`);
                    tickets.forEach(t => {
                        t.discrepancy_status = 'no-data';
                        t.discrepancy_diff = null;
                        t.pct_discrepancy = null;
                        t.matched_drain = null;
                        noDataCount++;
                        totalTickets++;
                    });
                    return;
                }
                
                // Create a copy of drain events to track which are matched
                const availableDrains = drainEvents.map((d, idx) => ({...d, idx}));
                
                // Sort tickets by amount (largest first) for better matching
                const sortedTickets = [...tickets].sort((a, b) => b.amount_collected - a.amount_collected);
                
                // Match each ticket to the closest available drain event
                sortedTickets.forEach(ticket => {
                    totalTickets++;
                    const VTicket = ticket.amount_collected || 0;
                    
                    // Find best matching drain event (closest VTrue to VTicket)
                    let bestMatch = null;
                    let bestDiff = Infinity;
                    let bestIdx = -1;
                    
                    availableDrains.forEach((drain, idx) => {
                        if (!drain.matched) {
                            const diff = Math.abs(drain.VTrue - VTicket);
                            if (diff < bestDiff) {
                                bestDiff = diff;
                                bestMatch = drain;
                                bestIdx = idx;
                            }
                        }
                    });
                    
                    if (bestMatch) {
                        // Mark drain as matched
                        availableDrains[bestIdx].matched = true;
                        drainEvents[bestMatch.idx].matched = true;
                        drainEvents[bestMatch.idx].matchedTicket = ticket.ticket_id;
                        
                        const VActual = bestMatch.VTrue;
                        const diff = VTicket - VActual;
                        const pctDisc = diff / VActual;
                        
                        ticket.discrepancy_diff = diff;
                        ticket.pct_discrepancy = pctDisc;
                        ticket.matched_drain = bestMatch.idx;
                        ticket.drain_VTrue = VActual;
                        
                        // Track all discrepancies for distribution analysis
                        discrepancies.push({
                            ticket_id: ticket.ticket_id,
                            pct: Math.abs(pctDisc),
                            diff: diff
                        });
                        
                        // Apply tolerance check
                        if (Math.abs(pctDisc) <= TOLERANCE) {
                            ticket.discrepancy_status = 'match';
                            matchCount++;
                        } else if (VTicket > VActual) {
                            ticket.discrepancy_status = 'over-reported';
                            overCount++;
                            console.log(`üö® OVER: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | VDrain: ${VActual.toFixed(2)}L | FillRate: ${bestMatch.fillRate.toFixed(2)}L/min | Diff: ${diff.toFixed(2)}L (${(pctDisc*100).toFixed(1)}%)`);
                        } else {
                            ticket.discrepancy_status = 'under-reported';
                            underCount++;
                            console.log(`üü° UNDER: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | VDrain: ${VActual.toFixed(2)}L | FillRate: ${bestMatch.fillRate.toFixed(2)}L/min | Diff: ${diff.toFixed(2)}L (${(pctDisc*100).toFixed(1)}%)`);
                        }
                    } else {
                        // No drain event to match - suspicious (ticket without corresponding drain)
                        ticket.discrepancy_status = 'no-drain-match';
                        ticket.discrepancy_diff = null;
                        ticket.pct_discrepancy = null;
                        ticket.matched_drain = null;
                        unmatchedCount++;
                        console.log(`‚ö†Ô∏è NO MATCH: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | No corresponding drain event found`);
                    }
                });
                
                // Log unmatched drain events (drains without tickets - potential missing tickets)
                availableDrains.forEach((drain, idx) => {
                    if (!drain.matched) {
                        console.log(`üìã UNMATCHED DRAIN: ${date} | ${cauldronId} | VDrain: ${drain.VTrue.toFixed(2)}L | No corresponding ticket found`);
                    }
                });
            });
            
            console.log(`\nSUMMARY: ${totalTickets} tickets | ‚úÖ ${matchCount} match | üö® ${overCount} over | üü° ${underCount} under | ‚ö†Ô∏è ${unmatchedCount} no-drain | ‚ùì ${noDataCount} no-data`);
            console.log(`Suspicious rate: ${((overCount + underCount + unmatchedCount) / totalTickets * 100).toFixed(1)}% (${overCount + underCount + unmatchedCount}/${totalTickets})`);
            
            // Log discrepancy distribution
            if (discrepancies.length > 0) {
                discrepancies.sort((a, b) => a.pct - b.pct);
                const percentiles = [0.25, 0.50, 0.75, 0.90, 0.95];
                console.log('\nDiscrepancy Distribution (% difference):');
                percentiles.forEach(p => {
                    const idx = Math.floor(discrepancies.length * p);
                    const val = discrepancies[idx]?.pct || 0;
                    console.log(`  ${(p*100).toFixed(0)}th percentile: ${(val*100).toFixed(1)}%`);
                });
                const maxDisc = discrepancies[discrepancies.length - 1];
                console.log(`  Max: ${(maxDisc.pct*100).toFixed(1)}% (Ticket ${maxDisc.ticket_id})`);
            }
        }

        // Extend suspicious logic to include excess/deficit discrepancies
        // Flag tickets as suspicious per spec: over/under-reported beyond tolerance
        function isTicketSuspicious(ticket) {
            if (ticket.is_suspicious || ticket.suspicious) return true;
            // Per spec: OVER-REPORTED and UNDER-REPORTED are both flagged
            if (ticket.discrepancy_status === 'over-reported' || ticket.discrepancy_status === 'under-reported') return true;
            return false;
        }
        
        // Populate filter checkboxes with unique values
        function populateFilterDropdowns() {
            const cauldrons = [...new Set(allTickets.map(t => t.cauldron_id))].sort();
            const couriers = [...new Set(allTickets.map(t => t.courier_id))].sort();
            
            const cauldronContainer = document.getElementById('filter-cauldron-container');
            cauldrons.forEach(cauldron => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = cauldron;
                checkbox.id = `cauldron-${cauldron}`;
                checkbox.checked = true;
                checkbox.onchange = function(){ applyFiltersAndSort(); updateDropdownLabels(); };

                const labelEl = document.createElement('label');
                labelEl.setAttribute('for', checkbox.id);
                labelEl.textContent = cauldron;

                item.appendChild(checkbox);
                item.appendChild(labelEl);
                cauldronContainer.appendChild(item);
            });
            
            const courierContainer = document.getElementById('filter-courier-container');
            couriers.forEach(courier => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = courier;
                checkbox.id = `courier-${courier}`;
                checkbox.checked = true;
                checkbox.onchange = function(){ applyFiltersAndSort(); updateDropdownLabels(); };

                const labelEl = document.createElement('label');
                labelEl.setAttribute('for', checkbox.id);
                labelEl.textContent = courier;

                item.appendChild(checkbox);
                item.appendChild(labelEl);
                courierContainer.appendChild(item);
            });
            updateDropdownLabels();
        }
        
        // Apply filters and sorting
        function applyFiltersAndSort() {
            const sortBy = document.getElementById('sort-by').value;
            // Get selected cauldrons
            const selectedCauldrons = Array.from(document.querySelectorAll('#filter-cauldron-container input:checked'))
                .map(cb => cb.value);
            
            // Get selected couriers
            const selectedCouriers = Array.from(document.querySelectorAll('#filter-courier-container input:checked'))
                .map(cb => cb.value);
            
            const filterDate = document.getElementById('filter-date').value;
            
            // Get selected statuses
            const selectedStatuses = Array.from(document.querySelectorAll('#filter-status-container input:checked'))
                .map(cb => cb.value);
            
            // Start with all tickets
            filteredTickets = [...allTickets];
            
            // Apply cauldron filter (if any selected)
            if (selectedCauldrons.length > 0) {
                filteredTickets = filteredTickets.filter(t => selectedCauldrons.includes(t.cauldron_id));
            }
            
            // Apply courier filter (if any selected)
            if (selectedCouriers.length > 0) {
                filteredTickets = filteredTickets.filter(t => selectedCouriers.includes(t.courier_id));
            }
            
            if (filterDate) {
                filteredTickets = filteredTickets.filter(t => t.date === filterDate);
            }
            
            // Apply status filter
            if (selectedStatuses.length > 0 && selectedStatuses.length < 2) {
                // Only filter if not all statuses are selected
                if (selectedStatuses.includes('suspicious')) {
                    filteredTickets = filteredTickets.filter(t => isTicketSuspicious(t));
                } else if (selectedStatuses.includes('normal')) {
                    filteredTickets = filteredTickets.filter(t => !isTicketSuspicious(t));
                }
            }
            
            // Apply sorting
            switch(sortBy) {
                case 'date-desc':
                    filteredTickets.sort((a, b) => b.date.localeCompare(a.date));
                    break;
                case 'date-asc':
                    filteredTickets.sort((a, b) => a.date.localeCompare(b.date));
                    break;
                case 'amount-desc':
                    filteredTickets.sort((a, b) => b.amount_collected - a.amount_collected);
                    break;
                case 'amount-asc':
                    filteredTickets.sort((a, b) => a.amount_collected - b.amount_collected);
                    break;
            }
            
            // Reset to first page
            currentTicketPage = 1;
            displayTickets();
        }
        
        // Reset all filters
        function resetFilters() {
            document.getElementById('sort-by').value = 'date-desc';
            document.getElementById('filter-date').value = '';
            
            // Check all cauldron checkboxes
            document.querySelectorAll('#filter-cauldron-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            // Check all courier checkboxes
            document.querySelectorAll('#filter-courier-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            // Check all status checkboxes
            document.querySelectorAll('#filter-status-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            updateDropdownLabels();
            applyFiltersAndSort();
        }
        
        // Update statistics panel
        function updateStatistics() {
            const statusCounts = {
                match: 0,
                'over-reported': 0,
                'under-reported': 0,
                'no-drain-match': 0,
                'no-data': 0
            };
            
            // Count tickets by status
            filteredTickets.forEach(ticket => {
                const status = ticket.discrepancy_status || 'no-data';
                if (statusCounts.hasOwnProperty(status)) {
                    statusCounts[status]++;
                }
            });
            
            const total = filteredTickets.length;
            const suspicious = statusCounts['over-reported'] + statusCounts['under-reported'] + statusCounts['no-drain-match'];
            const validMatches = statusCounts.match;
            
            // Determine color for suspicious rate
            let suspiciousColor = '#66ff66'; // green
            if (suspicious > total * 0.2) suspiciousColor = '#ff6666'; // red
            else if (suspicious > total * 0.1) suspiciousColor = '#ffaa66'; // orange
            else if (suspicious > total * 0.05) suspiciousColor = '#ffff66'; // yellow
            
            // Build stats HTML
            const statsHTML = `
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">‚úÖ Match Tickets</div>
                    <div class="ticket-stat-value">${validMatches}/${total}</div>
                </div>
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">‚ö†Ô∏è Suspicious Tickets</div>
                    <div class="ticket-stat-value" style="color: ${suspiciousColor};">${suspicious}/${total}</div>
                    <div class="ticket-stat-sub">Over: ${statusCounts['over-reported']} | Under: ${statusCounts['under-reported']} | No-Drain: ${statusCounts['no-drain-match']}</div>
                </div>
                <div class="ticket-stat-card ticket-stat-muted">
                    <div class="ticket-stat-label">üìà [Future Metric]</div>
                    <div class="ticket-stat-value">-</div>
                </div>
                <div class="ticket-stat-card ticket-stat-muted">
                    <div class="ticket-stat-label">üìâ [Future Metric]</div>
                    <div class="ticket-stat-value">-</div>
                </div>
            `;
            
            document.getElementById('ticket-stats').innerHTML = statsHTML;
        }
        
        // Display tickets for current page
        function displayTickets() {
            const tbody = document.getElementById('ticket-tbody');
            tbody.innerHTML = '';
            
            const totalPages = Math.ceil(filteredTickets.length / ticketsPerPage);
            const startIndex = (currentTicketPage - 1) * ticketsPerPage;
            const endIndex = Math.min(startIndex + ticketsPerPage, filteredTickets.length);
            
            const ticketsToShow = filteredTickets.slice(startIndex, endIndex);
            
            // Update statistics
            updateStatistics();
            
            ticketsToShow.forEach(ticket => {
                const row = document.createElement('tr');
                const isSuspicious = isTicketSuspicious(ticket);
                
                if (isSuspicious) {
                    row.classList.add('suspicious');
                }
                // Status text per spec flags
                let statusText = 'Unknown';
                if (ticket.discrepancy_status === 'match') statusText = '‚úÖ Match';
                else if (ticket.discrepancy_status === 'over-reported') statusText = 'üö® Over-Reported';
                else if (ticket.discrepancy_status === 'under-reported') statusText = 'üü° Under-Reported';
                else if (ticket.discrepancy_status === 'no-drain-match') statusText = '‚ö†Ô∏è No Drain Match';
                else if (ticket.discrepancy_status === 'no-data') statusText = '‚ùì No Historical Data';

                row.innerHTML = `
                    <td>${ticket.ticket_id || 'N/A'}</td>
                    <td>${ticket.cauldron_id || 'N/A'}</td>
                    <td>${ticket.amount_collected ? ticket.amount_collected.toFixed(2) : 'N/A'}</td>
                    <td>${ticket.courier_id || 'N/A'}</td>
                    <td>${ticket.date || 'N/A'}</td>
                    <td>${isSuspicious ? '<span class=\"suspicious-badge\">SUSPICIOUS</span>' : statusText}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Update pagination
            document.getElementById('ticket-page-info').textContent = `Page ${currentTicketPage} of ${totalPages}`;
            document.getElementById('ticket-prev').disabled = currentTicketPage === 1;
            document.getElementById('ticket-next').disabled = currentTicketPage === totalPages;
        }
        
        // Change ticket page
        function changeTicketPage(delta) {
            const totalPages = Math.ceil(allTickets.length / ticketsPerPage);
            currentTicketPage = Math.max(1, Math.min(totalPages, currentTicketPage + delta));
            displayTickets();
        }
        
        // Main initialization
        async function init() {
            initMap();
            
            const cauldronsLoaded = await loadCauldrons();
            const marketLoaded = await loadMarket();
            const networkLoaded = await loadNetwork();
            const timestampsLoaded = await loadTimestamps();
            const ticketsLoaded = await loadTickets();
            
            if (cauldronsLoaded && timestampsLoaded) {
                document.getElementById('loading').style.display = 'none';
                centerMap();
                setupTimelineControls();
                
                // Load the latest data if available
                if (cachedData && cachedData.length > 0) {
                    await loadLevelsAtIndex(cachedData.length - 1);
                }

                // After both data and tickets are ready, compute discrepancies and refresh view
                computeDailyDrainEvents();
                annotateTicketDiscrepancies();
                applyFiltersAndSort();
            }
        }
        
        // Start the app
        init();
    </script>
</body>
</html>
