<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brew View - Potion Flow Monitoring</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Chart.js for trend charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- Three.js for 3D visualization -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    
    <!-- Google Fonts - Magical/RPG font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #120b2f 0%, #1a0f3d 50%, #0f0a28 100%);
            background-attachment: fixed;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            transition: background 0.5s ease, color 0.5s ease;
        }

        /* Light mode styles */
        body.light-mode {
            background: linear-gradient(135deg, #e8eaf6 0%, #c5cae9 50%, #9fa8da 100%);
        }

        body.light-mode .header {
            background: rgba(255, 255, 255, 0.8);
        }

        body.light-mode .header h1 {
            color: #5e35b1;
            text-shadow: 0 0 20px rgba(94, 53, 177, 0.4), 0 0 40px rgba(94, 53, 177, 0.2);
        }

        body.light-mode .header p {
            color: rgba(0, 0, 0, 0.7);
        }

        body.light-mode .tab {
            background: rgba(255, 255, 255, 0.6);
            color: rgba(0, 0, 0, 0.8);
        }

        body.light-mode .tab.active {
            background: rgba(255, 255, 255, 0.9);
            color: #5e35b1;
        }

        body.light-mode .map-container,
        body.light-mode .info-panel,
        body.light-mode .bar-chart-container,
        body.light-mode .timeline-container,
        body.light-mode .threejs-container {
            background: rgba(255, 255, 255, 0.8);
        }

        body.light-mode .info-panel h2,
        body.light-mode .map-container h2,
        body.light-mode .bar-chart-container h2,
        body.light-mode .timeline-container h2,
        body.light-mode .threejs-container h2 {
            color: #5e35b1;
        }

        body.light-mode .loading {
            color: #5e35b1;
        }

        /* Animated gradient background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(102, 126, 234, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(118, 75, 162, 0.1) 0%, transparent 50%);
            animation: gradientShift 15s ease infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gradientShift {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }
        
        /* Floating potion decorations */
        .floating-potions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }
        
        .floating-potion {
            position: absolute;
            width: 100px;
            height: 100px;
            opacity: 0.4;
            animation: float 20s infinite ease-in-out;
        }
        
        @keyframes float {
            0%, 100% {
                transform: translateY(0) rotate(var(--rotation));
            }
            50% {
                transform: translateY(-30px) rotate(calc(var(--rotation) + 5deg));
            }
        }
        
        /* Make sure main content is above floating potions */
        .header, .tabs, .content {
            position: relative;
            z-index: 1;
        }
        
        h2 {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            letter-spacing: 1px;
        }
        
        .header {
            background: rgba(42, 23, 63, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeInDown 0.8s ease;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header h1 {
            color: #667eea;
            text-align: center;
            font-size: 72px;
            line-height: 90px;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(102, 126, 234, 0.4);
            animation: glow 3s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% {
                text-shadow: 0 0 20px rgba(102, 126, 234, 0.8), 0 0 40px rgba(102, 126, 234, 0.4);
            }
            50% {
                text-shadow: 0 0 30px rgba(102, 126, 234, 1), 0 0 60px rgba(102, 126, 234, 0.6);
            }
        }
        .brand {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        .brand .witch-head {
            height: 90px;
            width: auto;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: transform 0.5s ease;
        }
        .brand .witch-head:hover {
            transform: scale(1.1) rotate(5deg);
        }
        .brand .witch-head.flipped {
            transform: scaleX(-1);
        }
        .brand .witch-head.flipped:hover {
            transform: scaleX(-1) scale(1.1) rotate(-5deg);
        }
        .brand .logo {
            height: 90px;
            width: auto;
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.2));
        }
        
        .header p {
            text-align: center;
            color: rgba(255,255,255,0.85);
            margin-top: 5px;
        }
        
        /* Tabs */
        .tabs {
            max-width: 1400px;
            margin: 20px auto 0;
            padding: 0 20px;
            display: flex;
            gap: 10px;
            animation: fadeInUp 0.8s ease 0.2s backwards;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab {
            background: rgba(245, 245, 245, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px 30px 15px 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .tab:hover::before {
            left: 100%;
        }

        .tab:hover {
            background: rgba(245, 245, 245, 0.15);
            color: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .tab.active {
            background: rgba(230, 230, 234, 0.2);
            color: #667eea;
            border-bottom: none;
            box-shadow: 0 -4px 12px rgba(102, 126, 234, 0.3);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .tab-content.active {
            display: block;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto 20px;
            padding: 0 20px;
        }
        
        .map-container {
            background: rgba(230, 230, 234, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 0 10px 10px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 60px rgba(102, 126, 234, 0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .map-container:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 80px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }
        
        #map {
            height: 600px;
            width: 100%;
            border-radius: 8px;
        }

        /* Darken base map tiles so marker glow pops */
        .leaflet-tile-pane {
            filter: brightness(0.55) contrast(1.1) saturate(0.85);
        }
        /* Optional: slightly darker map background while tiles load */
        #map {
            background-color: #0f1324;
        }
        
        .info-panel {
            background: rgba(230, 230, 234, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 0 10px 10px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 60px rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .info-panel:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 80px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .info-panel h2 {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.8), rgba(102, 126, 234, 0.6));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 24px rgba(118, 75, 162, 0.4), 0 0 30px rgba(102, 126, 234, 0.3);
        }

        .stat-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-card p {
            opacity: 0.95;
            font-size: 0.9em;
        }
        
        /* Bar chart for cauldron levels */
        .bar-chart-container {
            background: rgba(230, 230, 234, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 0 10px 10px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 60px rgba(102, 126, 234, 0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .bar-chart-container:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 80px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .bar-chart-container h2 {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        .bar-chart {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            height: 300px;
            padding: 10px;
            background: rgba(255,255,255,0.5);
            border-radius: 5px;
        }
        
        .bar-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            gap: 5px;
            height: 100%;
        }
        
        .bar {
            width: 100%;
            background: #3a5a9a; /* dark blue default */
            border-radius: 4px 4px 0 0;
            transition: all 0.3s ease;
            position: relative;
            min-height: 5px;
        }
        
        .bar.draining {
            background: #8b1a1a; /* dark red for draining */
        }
        
        .bar-label {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            text-align: center;
            word-break: break-word;
        }
        
        .bar-value {
            font-size: 10px;
            color: #666;
            font-weight: 500;
        }
        
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: #667eea;
            font-size: 1.2em;
            font-weight: 600;
            position: relative;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 40px;
            height: 40px;
            margin-left: 15px;
            border: 4px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Skeleton loading animation */
        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }

        .skeleton {
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 25%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.05) 75%);
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
            border-radius: 8px;
        }
        
        /* Cauldron Trends Styles */
        .trends-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: flex-end;
        }
        
        .trend-chart-wrapper {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-height: 500px;
        }
        
        #trend-chart {
            width: 100% !important;
            height: 500px !important;
        }
        
        .error {
            background: #fee;
            color: #c00;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        /* Timeline Slider */
        .timeline-container {
            background: rgba(230, 230, 234, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 60px rgba(102, 126, 234, 0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .timeline-container:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 80px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .timeline-container h2 {
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        .date-selector {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-bottom: 15px;
        }
        
        .date-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .date-group label {
            font-weight: bold;
            margin-bottom: 5px;
            padding-bottom: 15px;
            color: #667eea;
            font-size: 16px;
            text-align: center;
        }
        
        .date-group select {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 14px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
            max-width: 120px;
        }
        
        .slider-row {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            margin-bottom: 15px;
            margin-top: -5px;
        }
        
        .slider-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 0px;
        }
        
        .timeline-slider {
            width: 100%;
        }
        
        .timeline-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .timeline-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .show-btn-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .timeline-btn {
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.9), rgba(102, 126, 234, 0.7));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .timeline-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(118, 75, 162, 0.4), 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .timeline-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .timeline-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(50%);
        }
        
        .show-btn {
            background: #764ba2; /* solid purple */
            font-size: 16px;
            font-weight: bold;
            padding: 10px 30px;
        }
        
        .timestamp-display {
            font-size: 1.1em;
            color: #667eea;
            font-weight: bold;
        }
        
        .time-slider-container {
            padding: 15px;
            background: #e6e6ea; /* slightly dimmer light gray */
            border-radius: 8px;
        }
        
        .time-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }
        
        /* Ticket Logs Styles */
        .ticket-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .ticket-table th {
            background: #764ba2; /* solid purple */
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .ticket-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .ticket-table tr:hover {
            background: #e6e6ea;
        }
        
        .ticket-table tr.suspicious {
            background: #ffe6e6;
        }
        
        .ticket-table tr.suspicious:hover {
            background: #ffd6d6;
        }
        
        .suspicious-badge {
            background: #ff4444;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .pagination button {
            background: #764ba2; /* solid purple */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination button:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        .pagination span {
            color: #667eea;
            font-weight: 600;
        }

        /* Ticket stat cards (Ticket Logs summary boxes) */
        .ticket-stat-card {
            background: #d9681a; /* darker orange background */
            color: #ffffff; /* white text */
            padding: 12px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ticket-stat-card .ticket-stat-label {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-bottom: 2px;
            font-weight: 600;
        }
        .ticket-stat-card .ticket-stat-value {
            color: #ffffff;
            font-size: 28px;
            font-weight: 700;
            line-height: 1;
        }
        .ticket-stat-card .ticket-stat-sub {
            color: rgba(255,255,255,0.85);
            font-size: 11px;
            margin-top: 4px;
        }
        .ticket-stat-muted {
            opacity: 0.8;
        }
        /* helper for inline icons */
        .inline-icon {
            height: 1.2em;
            width: auto;
            vertical-align: middle;
            margin-right: 8px;
        }
        /* Larger map pin specifically */
        .map-container h2 .inline-icon {
            height: 2.4em; /* twice normal inline icon height */
        }
        /* slightly larger inline icon specifically for ticket icons */
        .inline-icon-ticket {
            height: 1.6em;
            width: auto;
            vertical-align: middle;
            margin-right: 8px;
        }
        
        /* Ticket Filters */
        .ticket-filters {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Dropdown checkbox container */
        .dropdown-filter {
            position: relative;
            width: 180px;
        }

        .dropdown-filter-toggle {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .dropdown-filter-toggle:hover {
            background: #f3f6ff;
        }

        .dropdown-filter-menu {
            position: absolute;
            top: 105%;
            left: 0;
            z-index: 50;
            background: #e6e6ea; /* slightly dimmer light gray */
            border: 2px solid #667eea;
            border-radius: 6px;
            max-height: 260px;
            overflow-y: auto;
            padding: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
            display: none;
            width: 100%;
        }

        .dropdown-filter.open .dropdown-filter-menu {
            display: block;
        }

        /* Avoid nested scrollbars: let the menu scroll, not inner list */
        .dropdown-filter-menu .checkbox-group {
            max-height: none;
            overflow: visible;
            border: none;
            padding: 0;
        }
        
        .filter-group label {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
        }
        
        .filter-group select,
        .filter-group input {
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 14px;
            background: #e6e6ea; /* slightly dimmer light gray */
            cursor: pointer;
        }
        
        .checkbox-group {
            max-height: 150px;
            overflow-y: auto;
            border: 2px solid #667eea;
            border-radius: 5px;
            padding: 8px;
            background: #e6e6ea; /* slightly dimmer light gray */
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .checkbox-item label {
            font-weight: normal;
            color: #333;
            font-size: 13px;
            cursor: pointer;
            margin: 0;
        }
        
        .filter-group button {
            background: #764ba2; /* solid purple */
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 23px;
        }
        
        .filter-group button:hover {
            opacity: 0.9;
        }
        
        /* Custom marker styles */
        /* Legacy circle marker (kept for reference)
        .cauldron-marker {
            background: white;
            border: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        */
        .cauldron-img-wrapper {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .cauldron-img {
            width: 28px;
            height: 28px;
            object-fit: contain;
            pointer-events: none;
        }
        .glow-green-light {
            filter: drop-shadow(0 0 6px rgba(144, 238, 144, 0.9)) drop-shadow(0 0 12px rgba(144, 238, 144, 0.5)); /* lightgreen */
        }
        .glow-green-yellow {
            filter: drop-shadow(0 0 6px rgba(173, 255, 47, 0.9)) drop-shadow(0 0 12px rgba(173, 255, 47, 0.55)); /* greenyellow */
        }
        .glow-yellow {
            filter: drop-shadow(0 0 6px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 12px rgba(255, 215, 0, 0.55)); /* gold */
        }
        .glow-orange {
            filter: drop-shadow(0 0 6px rgba(255, 140, 0, 0.95)) drop-shadow(0 0 12px rgba(255, 140, 0, 0.55)); /* darkorange */
        }
        .glow-red {
            filter: drop-shadow(0 0 6px rgba(220, 20, 60, 0.95)) drop-shadow(0 0 12px rgba(220, 20, 60, 0.6)); /* crimson */
        }
        
        .market-marker {
            background: #ff6b6b;
            border: 3px solid #c92a2a;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        /* 3D Visualization Styles */
        .threejs-container {
            background: rgba(230, 230, 234, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 0 10px 10px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 0 0 60px rgba(102, 126, 234, 0.1);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .threejs-container:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4), 0 0 80px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .threejs-container h2 {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
            margin-bottom: 15px;
        }

        #threejs-canvas {
            width: 100%;
            height: 700px;
            border-radius: 10px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            background: radial-gradient(circle at center, rgba(15, 19, 36, 0.9), rgba(12, 11, 47, 1));
            cursor: grab;
        }

        #threejs-canvas:active {
            cursor: grabbing;
        }

        /* 3D Legend Overlay */
        .threejs-legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.5);
            color: white;
            font-size: 13px;
            line-height: 1.8;
            z-index: 10;
            pointer-events: none;
        }

        .threejs-legend h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #667eea;
            border-bottom: 1px solid rgba(102, 126, 234, 0.3);
            padding-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .threejs-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .threejs-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .threejs-control-group label {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
        }

        .threejs-control-btn {
            background: linear-gradient(135deg, rgba(118, 75, 162, 0.9), rgba(102, 126, 234, 0.7));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .threejs-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(118, 75, 162, 0.4), 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .threejs-control-btn:active {
            transform: translateY(0);
        }

        .threejs-info {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .threejs-info p {
            color: rgba(255, 255, 255, 0.85);
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Floating potion decorations -->
    <div class="floating-potions" id="floating-potions"></div>
    
    <div class="header">
        <button id="theme-toggle" onclick="toggleTheme()" style="position: absolute; top: 20px; right: 20px; background: rgba(255, 255, 255, 0.2); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; transition: all 0.3s ease; z-index: 100;">
            üåô Dark Mode
        </button>
        <div class="brand">
            <img class="witch-head" src="{{ url_for('static', filename='images/markers/witchHead.png') }}" alt="Witch" />
            <img class="logo" src="{{ url_for('static', filename='images/logo.png') }}" alt="Brew View Logo" />
            <h1>ùï≠ùñóùñäùñú ùì•ùñéùñäùñú</h1>
            <img class="witch-head flipped" src="{{ url_for('static', filename='images/markers/witchHead.png') }}" alt="Witch" />
        </div>
    </div>
    
    <!-- Tabs Navigation -->
    <div class="tabs">
    <button class="tab active" onclick="switchTab('map', this)"><img src="{{ url_for('static', filename='images/markers/pin.png') }}" alt="Map" class="inline-icon"> Map</button>
    <button class="tab" onclick="switchTab('3d', this)">üîÆ 3D Visualization</button>
    <button class="tab" onclick="switchTab('tickets', this)"><img src="{{ url_for('static', filename='images/markers/ticket.png') }}" alt="Tickets" class="inline-icon-ticket"> Ticket Logs</button>
    <button class="tab" onclick="switchTab('trends', this)">üìà Cauldron Trends</button>
    <button class="tab" onclick="switchTab('analytics', this)">üìä Analytics Dashboard</button>
    <button class="tab" onclick="switchTab('optimization', this)">üó∫Ô∏è Route Optimization</button>
    </div>
    
    <!-- Map Tab Content -->
    <div id="map-tab" class="tab-content active">
        <div class="container">
            <div class="map-container">
                <h2><img src="{{ url_for('static', filename='images/markers/pin.png') }}" alt="Map" class="inline-icon"> Cauldron Network Map</h2>
                <div id="loading" class="loading">Loading cauldron data...</div>
                <div id="map"></div>
            </div>
        
        <div class="timeline-container">
            <h2><img src="{{ url_for('static', filename='images/markers/hourglass.png') }}" alt="Timeline" class="inline-icon"> Historical Timeline</h2>
            
            <!-- Date and Time Selection Row -->
            <div class="slider-row">
                <!-- Date Selectors on the left -->
                <div class="date-selector">
                    <div class="date-group">
                        <label for="year-select">Year</label>
                        <select id="year-select">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="month-select">Month</label>
                        <select id="month-select">
                            <option value="">Select year first</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="day-select">Day</label>
                        <select id="day-select">
                            <option value="">Select month first</option>
                        </select>
                    </div>
                    <div class="date-group">
                        <label for="timezone-select">Timezone</label>
                        <select id="timezone-select">
                            <option value="UTC">UTC</option>
                            <option value="America/New_York">Eastern (ET)</option>
                            <option value="America/Chicago">Central (CT)</option>
                            <option value="America/Denver">Mountain (MT)</option>
                            <option value="America/Los_Angeles">Pacific (PT)</option>
                            <option value="America/Phoenix">Arizona (MST)</option>
                            <option value="America/Anchorage">Alaska (AKT)</option>
                            <option value="Pacific/Honolulu">Hawaii (HST)</option>
                            <option value="Europe/London">London (GMT/BST)</option>
                            <option value="Europe/Paris">Paris (CET)</option>
                            <option value="Asia/Tokyo">Tokyo (JST)</option>
                            <option value="Asia/Shanghai">Shanghai (CST)</option>
                            <option value="Australia/Sydney">Sydney (AEDT)</option>
                        </select>
                    </div>
                </div>
                
                <!-- Time Slider on the right -->
                <div class="slider-section">
                    <div class="time-label">Time of Day:</div>
                    <div class="timeline-info">
                        <div>
                            <span class="timestamp-display" id="current-timestamp">Select a date...</span>
                        </div>
                    </div>
                    <input type="range" class="timeline-slider" id="time-slider" 
                           min="0" max="0" value="0" step="1" disabled>
                    
                    <!-- Playback Controls centered underneath timeline -->
                    <div class="timeline-controls">
                        <button class="timeline-btn" id="btn-first">‚èÆÔ∏è First</button>
                        <button class="timeline-btn" id="btn-prev">‚è™ Previous</button>
                        <button class="timeline-btn" id="btn-play">‚ñ∂Ô∏è Play</button>
                        <button class="timeline-btn" id="btn-next">Next ‚è©</button>
                        <button class="timeline-btn" id="btn-last">‚è≠Ô∏è Last</button>
                    </div>
                </div>
            </div>
            
            <!-- Show Button -->
            <div class="show-btn-container">
                <button class="timeline-btn show-btn" id="btn-show">üîç Show</button>
            </div>
        </div>
        
        <!-- Bar Chart for Cauldron Levels -->
        <div class="bar-chart-container">
            <h2>üìä Cauldron Levels</h2>
            <div class="bar-chart" id="cauldron-bar-chart">
                <!-- Bars will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="info-panel">
            <h2>üìä Network Statistics</h2>
            <div class="stats" id="stats">
                <!-- Stats will be populated by JavaScript -->
            </div>
        </div>
        </div>
    </div>

    <!-- 3D Visualization Tab Content -->
    <div id="3d-tab" class="tab-content">
        <div class="container">
            <div class="threejs-container">
                <h2>üîÆ Interactive 3D Potion Network</h2>
                <div id="threejs-loading" class="loading">Initializing 3D scene...</div>
                <div id="threejs-canvas" style="position: relative;">
                    <div class="threejs-legend">
                        <h3>üìä Legend</h3>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #90ee90;"></div>
                            <span>0-40% Full (Green)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #adff2f;"></div>
                            <span>40-60% Full (Yellow-Green)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffd700;"></div>
                            <span>60-75% Full (Gold)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff8c00;"></div>
                            <span>75-90% Full (Orange)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #dc143c;"></div>
                            <span>90-100% Full (Red)</span>
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(102, 126, 234, 0.3);">
                            <div class="legend-item">
                                <span>üè™</span>
                                <span>= Market (Center)</span>
                            </div>
                            <div class="legend-item">
                                <span>‚öóÔ∏è</span>
                                <span>= Cauldrons (Around)</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="threejs-controls">
                    <button class="threejs-control-btn" onclick="resetCamera()">üéØ Reset View</button>
                    <button class="threejs-control-btn" onclick="toggleAnimation()">‚èØÔ∏è Toggle Animation</button>
                    <button class="threejs-control-btn" onclick="toggleParticles()">‚ú® Toggle Particles</button>
                    <button class="threejs-control-btn" onclick="changeViewMode()">üëÅÔ∏è Change View</button>
                </div>

                <div class="threejs-info">
                    <p><strong>Controls:</strong> Left-click + drag to rotate | Right-click + drag to pan | Scroll to zoom</p>
                    <p><strong>Features:</strong> Real-time 3D cauldron network with animated potion flows, particle effects, and interactive controls. Cauldron height represents fill level.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Ticket Logs Tab Content -->
    <div id="tickets-tab" class="tab-content">
        <div class="container">
            <div class="info-panel">
                <h2><img src="{{ url_for('static', filename='images/markers/ticket.png') }}" alt="Tickets" class="inline-icon-ticket"> Ticket Logs</h2>
                <div id="ticket-loading" class="loading">Loading tickets...</div>
                <div id="ticket-container" style="display: none;">
                    <!-- Statistics Panel -->
                    <div id="ticket-stats" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Stats will be populated here -->
                    </div>
                    
                    <!-- Filters and Sorting -->
                    <div class="ticket-filters">
                        <div class="filter-group">
                            <label for="sort-by">Sort By:</label>
                            <select id="sort-by" onchange="applyFiltersAndSort()">
                                <option value="date-desc">Date (Newest First)</option>
                                <option value="date-asc">Date (Oldest First)</option>
                                <option value="amount-desc">Amount (High to Low)</option>
                                <option value="amount-asc">Amount (Low to High)</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Cauldrons:</label>
                            <div class="dropdown-filter" id="cauldron-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('cauldron-dropdown')">
                                    <span id="cauldron-dropdown-label">All Cauldrons</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-cauldron-container"><!-- populated dynamically --></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <label>Couriers:</label>
                            <div class="dropdown-filter" id="courier-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('courier-dropdown')">
                                    <span id="courier-dropdown-label">All Couriers</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-courier-container"><!-- populated dynamically --></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <label for="filter-date">Date:</label>
                            <input type="date" id="filter-date" onchange="applyFiltersAndSort()">
                        </div>
                        
                        <div class="filter-group">
                            <label>Status:</label>
                            <div class="dropdown-filter" id="status-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('status-dropdown')">
                                    <span id="status-dropdown-label">All Statuses</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="filter-status-container">
                                        <div class="checkbox-item">
                                            <input type="checkbox" id="status-normal" value="normal" checked onchange="applyFiltersAndSort();updateDropdownLabels()">
                                            <label for="status-normal">Normal</label>
                                        </div>
                                        <div class="checkbox-item">
                                            <input type="checkbox" id="status-suspicious" value="suspicious" checked onchange="applyFiltersAndSort();updateDropdownLabels()">
                                            <label for="status-suspicious">Suspicious</label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <button onclick="resetFilters()">Reset Filters</button>
                        </div>
                    </div>
                    
                    <table class="ticket-table" id="ticket-table">
                        <thead>
                            <tr>
                                <th>Ticket ID</th>
                                <th>Cauldron</th>
                                <th>Amount Collected</th>
                                <th>Courier</th>
                                <th>Date</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="ticket-tbody">
                            <!-- Tickets will be populated here -->
                        </tbody>
                    </table>
                    <div class="pagination">
                        <button id="ticket-prev" onclick="changeTicketPage(-1)">‚è™ Previous</button>
                        <span id="ticket-page-info">Page 1 of 1</span>
                        <button id="ticket-next" onclick="changeTicketPage(1)">Next ‚è©</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Cauldron Trends Tab Content -->
    <div id="trends-tab" class="tab-content">
        <div class="container">
            <div class="info-panel">
                <h2>üìà Cauldron Trends</h2>
                <div id="trends-loading" class="loading">Loading trend data...</div>
                <div id="trends-container" style="display: none;">
                    <!-- Date and Cauldron Filters -->
                    <div class="trends-filters">
                        <div class="filter-group">
                            <label for="trends-year">Year:</label>
                            <select id="trends-year" onchange="updateTrendsGraph()">
                                <option value="">Loading...</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="trends-month">Month:</label>
                            <select id="trends-month" onchange="updateTrendsGraph()">
                                <option value="">Select year first</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="trends-day">Day:</label>
                            <select id="trends-day" onchange="updateTrendsGraph()">
                                <option value="">Select month first</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label for="trends-timezone">Timezone:</label>
                            <select id="trends-timezone" onchange="updateTrendsGraph()">
                                <option value="UTC">UTC</option>
                                <option value="America/New_York">Eastern (ET)</option>
                                <option value="America/Chicago">Central (CT)</option>
                                <option value="America/Denver">Mountain (MT)</option>
                                <option value="America/Los_Angeles">Pacific (PT)</option>
                                <option value="America/Phoenix">Arizona (MST)</option>
                                <option value="America/Anchorage">Alaska (AKT)</option>
                                <option value="Pacific/Honolulu">Hawaii (HST)</option>
                                <option value="Europe/London">London (GMT/BST)</option>
                                <option value="Europe/Paris">Paris (CET)</option>
                                <option value="Asia/Tokyo">Tokyo (JST)</option>
                                <option value="Asia/Shanghai">Shanghai (CST)</option>
                                <option value="Australia/Sydney">Sydney (AEDT)</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Cauldrons:</label>
                            <div class="dropdown-filter" id="trends-cauldron-dropdown">
                                <div class="dropdown-filter-toggle" onclick="toggleFilterDropdown('trends-cauldron-dropdown')">
                                    <span id="trends-cauldron-label">All Cauldrons</span>
                                    <span>‚ñæ</span>
                                </div>
                                <div class="dropdown-filter-menu">
                                    <div class="checkbox-group" id="trends-cauldron-container">
                                        <!-- Cauldron checkboxes will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="filter-group">
                            <button onclick="resetTrendsFilters()">Reset Filters</button>
                        </div>
                    </div>
                    
                    <!-- Trend Chart Container -->
                    <div class="trend-chart-wrapper">
                        <canvas id="trend-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Analytics Dashboard Tab Content -->
    <div id="analytics-tab" class="tab-content">
        <div class="container">
            <div class="info-panel">
                <h2>üìä Analytics Dashboard</h2>
                <div id="analytics-loading" class="loading">Loading analytics...</div>
                <div id="analytics-container" style="display: none;">
                    
                    <!-- Overview Stats -->
                    <div style="margin-bottom: 30px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">üìà Overview Statistics</h3>
                        <div class="stats" id="analytics-overview">
                            <!-- Overview stats will be populated here -->
                        </div>
                    </div>
                    
                    <!-- Courier Performance -->
                    <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">üöö Courier Performance</h3>
                        <div style="margin-bottom: 20px;">
                            <canvas id="courier-performance-chart" style="max-height: 400px;"></canvas>
                        </div>
                        <table class="ticket-table" id="courier-performance-table">
                            <thead>
                                <tr>
                                    <th>Courier</th>
                                    <th>Total Deliveries</th>
                                    <th>Total Collected (L)</th>
                                    <th>Avg per Delivery (L)</th>
                                    <th>Suspicious Rate</th>
                                    <th>Performance Rating</th>
                                </tr>
                            </thead>
                            <tbody id="courier-tbody">
                                <!-- Courier stats will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Cauldron Efficiency -->
                    <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">‚öóÔ∏è Cauldron Efficiency</h3>
                        <div style="margin-bottom: 20px;">
                            <canvas id="cauldron-efficiency-chart" style="max-height: 400px;"></canvas>
                        </div>
                        <table class="ticket-table" id="cauldron-efficiency-table">
                            <thead>
                                <tr>
                                    <th>Cauldron</th>
                                    <th>Total Collections</th>
                                    <th>Total Output (L)</th>
                                    <th>Avg Fill Rate (L/day)</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="cauldron-efficiency-tbody">
                                <!-- Cauldron stats will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Route Efficiency -->
                    <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">üõ£Ô∏è Network Efficiency</h3>
                        <div class="stats" id="network-stats">
                            <!-- Network stats will be populated here -->
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
    </div>
    
    <!-- Route Optimization Tab Content -->
    <div id="optimization-tab" class="tab-content">
        <div class="container">
            <div class="info-panel">
                <h2>üó∫Ô∏è Daily Pickup Schedule Optimization</h2>
                <div id="optimization-container">
                    
                    <!-- Introduction -->
                    <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">üìã Objective</h3>
                        <p style="color: #666; margin-bottom: 10px;">
                            Calculate the minimum number of witches needed to ensure <strong>no cauldron ever overflows</strong>, 
                            even well into the future. This system accounts for each cauldron's fill rate and creates a 
                            sustainable daily pickup schedule.
                        </p>
                        <button onclick="optimizeDailySchedule()" style="background: #667eea; color: white; border: none; padding: 12px 30px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; margin-top: 10px;">
                            üîÑ Calculate Optimal Daily Schedule
                        </button>
                    </div>
                    
                    <!-- Results Summary -->
                    <div id="optimization-results" style="display: none;">
                        <!-- Witch Count & Stats -->
                        <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üìä Optimization Results</h3>
                            <div class="stats" id="optimization-stats"></div>
                        </div>
                        
                        <!-- Route Map -->
                        <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üó∫Ô∏è Optimized Routes</h3>
                            <div id="route-map" style="height: 500px; border-radius: 10px; border: 2px solid #667eea;"></div>
                        </div>
                        
                        <!-- Daily Schedule -->
                        <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üßô Daily Witch Schedule (24-Hour View)</h3>
                            <p style="color: #666; margin-bottom: 10px; font-size: 14px;">
                                <strong>Note:</strong> Each witch's routes throughout a 24-hour period. Multiple witches may visit the same cauldron at different times.
                            </p>
                            <table class="ticket-table">
                                <thead>
                                    <tr>
                                        <th>Witch ID</th>
                                        <th>Route</th>
                                        <th>Cauldrons</th>
                                        <th>Distance (km)</th>
                                        <th>Time (min)</th>
                                        <th>Time Window</th>
                                    </tr>
                                </thead>
                                <tbody id="schedule-tbody"></tbody>
                            </table>
                        </div>
                        
                        <!-- Cauldron Analysis -->
                        <div style="background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 15px;">üîÆ Cauldron Fill Analysis</h3>
                            <p style="color: #666; margin-bottom: 10px; font-size: 14px;">
                                <strong>Note:</strong> Fill Rate = continuous accumulation | Drain Rate = collection speed (reference) | Net Rate = Fill Rate (cauldrons fill continuously between pickups)
                            </p>
                            <table class="ticket-table">
                                <thead>
                                    <tr>
                                        <th>Cauldron</th>
                                        <th>Current (L)</th>
                                        <th>Max (L)</th>
                                        <th>Fill Rate (L/hr)</th>
                                        <th>Collection Speed (L/hr)</th>
                                        <th>Net Accumulation (L/hr)</th>
                                        <th>Time to Full</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="cauldron-analysis-tbody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- OrbitControls for Three.js -->
    <script>
    // OrbitControls implementation for THREE.js
    (function() {
        if (typeof THREE !== 'undefined') {
            THREE.OrbitControls = function(object, domElement) {
                this.object = object;
                this.domElement = domElement;
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minZoom = 0;
                this.maxZoom = Infinity;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.enableDamping = false;
                this.dampingFactor = 0.05;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.panSpeed = 1.0;

                var scope = this;
                var changeEvent = { type: 'change' };
                var startEvent = { type: 'start' };
                var endEvent = { type: 'end' };
                var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
                var state = STATE.NONE;
                var EPS = 0.000001;

                var spherical = { radius: 1, theta: 0, phi: 0 };
                var sphericalDelta = { theta: 0, phi: 0 };
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();

                this.update = function() {
                    var offset = new THREE.Vector3();
                    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                    var quatInverse = quat.clone().invert();
                    var lastPosition = new THREE.Vector3();
                    var lastQuaternion = new THREE.Quaternion();

                    return function update() {
                        var position = scope.object.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);

                        var theta = Math.atan2(offset.x, offset.z);
                        var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

                        theta += sphericalDelta.theta;
                        phi += sphericalDelta.phi;
                        phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, phi));
                        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

                        var radius = offset.length() * scale;
                        radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, radius));

                        scope.target.add(panOffset);

                        offset.x = radius * Math.sin(phi) * Math.sin(theta);
                        offset.y = radius * Math.cos(phi);
                        offset.z = radius * Math.sin(phi) * Math.cos(theta);

                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.object.lookAt(scope.target);

                        if (scope.enableDamping === true) {
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                            panOffset.multiplyScalar(1 - scope.dampingFactor);
                        } else {
                            sphericalDelta.theta = 0;
                            sphericalDelta.phi = 0;
                            panOffset.set(0, 0, 0);
                        }

                        scale = 1;

                        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                            lastPosition.copy(scope.object.position);
                            lastQuaternion.copy(scope.object.quaternion);
                            zoomChanged = false;
                            return true;
                        }
                        return false;
                    };
                }();

                function onMouseDown(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();

                    if (event.button === 0) {
                        state = STATE.ROTATE;
                        rotateStart.set(event.clientX, event.clientY);
                    } else if (event.button === 2) {
                        state = STATE.PAN;
                        panStart.set(event.clientX, event.clientY);
                    }

                    if (state !== STATE.NONE) {
                        document.addEventListener('mousemove', onMouseMove, false);
                        document.addEventListener('mouseup', onMouseUp, false);
                    }
                }

                function onMouseMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();

                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
                        sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / scope.domElement.clientHeight;
                        sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / scope.domElement.clientHeight;
                        rotateStart.copy(rotateEnd);
                        scope.update();
                    } else if (state === STATE.PAN) {
                        panEnd.set(event.clientX, event.clientY);
                        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

                        var element = scope.domElement;
                        var offset = new THREE.Vector3();
                        offset.copy(scope.object.position).sub(scope.target);
                        var targetDistance = offset.length();
                        targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);

                        var panLeft = new THREE.Vector3();
                        panLeft.setFromMatrixColumn(scope.object.matrix, 0);
                        panLeft.multiplyScalar(-2 * panDelta.x * targetDistance / element.clientHeight);

                        var panUp = new THREE.Vector3();
                        panUp.setFromMatrixColumn(scope.object.matrix, 1);
                        panUp.multiplyScalar(2 * panDelta.y * targetDistance / element.clientHeight);

                        panOffset.add(panLeft).add(panUp);
                        panStart.copy(panEnd);
                        scope.update();
                    }
                }

                function onMouseUp(event) {
                    if (scope.enabled === false) return;
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }

                function onMouseWheel(event) {
                    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
                    event.preventDefault();
                    event.stopPropagation();

                    if (event.deltaY < 0) {
                        scale /= Math.pow(0.95, scope.zoomSpeed);
                    } else if (event.deltaY > 0) {
                        scale *= Math.pow(0.95, scope.zoomSpeed);
                    }

                    scope.update();
                }

                function onContextMenu(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                }

                this.domElement.addEventListener('contextmenu', onContextMenu, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, false);

                this.update();
            };
        }
    })();
    </script>

    <script>
        // Create floating potion decorations
        function createFloatingPotions() {
            const container = document.getElementById('floating-potions');
            const potionTypes = ['potBabyBlue', 'potCream', 'potGreen', 'potMagenta', 'potNavyBlue', 'potPurple', 'potYellow'];
            const numPotions = 8; // Not too many
            
            // Split evenly between left and right
            const potionsPerSide = numPotions / 2;
            
            for (let i = 0; i < numPotions; i++) {
                const potion = document.createElement('img');
                const potionType = potionTypes[Math.floor(Math.random() * potionTypes.length)];
                potion.src = `/static/images/markers/${potionType}.png`;
                potion.className = 'floating-potion';
                
                // Alternate between left and right side
                const isLeftSide = i < potionsPerSide;
                if (isLeftSide) {
                    // Left margin: 0-15% from left
                    potion.style.left = Math.random() * 15 + '%';
                } else {
                    // Right margin: 85-100% from left
                    potion.style.left = (85 + Math.random() * 15) + '%';
                }
                
                // Evenly distribute vertically with some randomness
                const basePosition = (i % potionsPerSide) * (100 / potionsPerSide);
                const randomOffset = (Math.random() - 0.5) * (100 / potionsPerSide) * 0.5; // 50% variation
                potion.style.top = Math.max(0, Math.min(100, basePosition + randomOffset)) + '%';
                
                // Random tilt between -45 and 45 degrees
                const rotation = (Math.random() * 90 - 45);
                potion.style.setProperty('--rotation', rotation + 'deg');
                
                // Random animation delay and duration for variety
                potion.style.animationDelay = Math.random() * 10 + 's';
                potion.style.animationDuration = (15 + Math.random() * 10) + 's';
                
                // Random size variation (80-120px, larger than before)
                const size = 80 + Math.random() * 40;
                potion.style.width = size + 'px';
                potion.style.height = size + 'px';
                
                container.appendChild(potion);
            }
        }
        
        // Create potions on page load
        createFloatingPotions();

        // Theme toggle function
        function toggleTheme() {
            const body = document.body;
            const button = document.getElementById('theme-toggle');

            body.classList.toggle('light-mode');

            if (body.classList.contains('light-mode')) {
                button.textContent = 'üåô Dark Mode';
                button.style.background = 'rgba(0, 0, 0, 0.2)';
                button.style.color = '#333';
                localStorage.setItem('theme', 'light');
            } else {
                button.textContent = '‚òÄÔ∏è Light Mode';
                button.style.background = 'rgba(255, 255, 255, 0.2)';
                button.style.color = 'white';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Load saved theme preference
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const button = document.getElementById('theme-toggle');

            if (savedTheme === 'light') {
                body.classList.add('light-mode');
                button.textContent = 'üåô Dark Mode';
                button.style.background = 'rgba(0, 0, 0, 0.2)';
                button.style.color = '#333';
            } else {
                button.textContent = '‚òÄÔ∏è Light Mode';
            }
        }

        // Load theme on page load
        window.addEventListener('DOMContentLoaded', loadTheme);

        // Tab switching function
        function switchTab(tabName, element) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Add active class to clicked tab
            if (element) {
                element.classList.add('active');
            }
            
            // If switching to map tab, invalidate size to fix rendering issues
            if (tabName === 'map' && map) {
                setTimeout(() => map.invalidateSize(), 100);
            }
            
            // If switching to trends tab, initialize it
            if (tabName === 'trends') {
                setTimeout(() => initTrendsTab(), 100);
            }
            
            // If switching to analytics tab, initialize it
            if (tabName === 'analytics') {
                setTimeout(() => initAnalyticsTab(), 100);
            }
            
            // If switching to optimization tab, initialize it
            if (tabName === 'optimization') {
                setTimeout(() => initOptimizationTab(), 100);
            }
        }

        // Build a cauldron icon using PNG with a color glow based on fill percent
        function getCauldronIcon(fillPercent) {
            let glowClass = 'glow-green-light';
            const p = typeof fillPercent === 'number' ? fillPercent : parseFloat(fillPercent) || 0;
            if (p > 90) glowClass = 'glow-red';
            else if (p > 75) glowClass = 'glow-orange';
            else if (p > 60) glowClass = 'glow-yellow';
            else if (p > 40) glowClass = 'glow-green-yellow';

            const imgSrc = "{{ url_for('static', filename='images/markers/cauldron.png') }}";
            const html = `<div class="cauldron-img-wrapper ${glowClass}"><img class="cauldron-img" src="${imgSrc}" alt="Cauldron" /></div>`;
            return L.divIcon({
                className: 'custom-icon',
                html,
                iconSize: [36, 36],
                iconAnchor: [18, 18]
            });
        }

        // Dropdown checkbox helpers
        function toggleFilterDropdown(id) {
            const dd = document.getElementById(id);
            const isOpen = dd.classList.contains('open');
            // Close all first
            document.querySelectorAll('.dropdown-filter.open').forEach(el => el.classList.remove('open'));
            if (!isOpen) dd.classList.add('open');
        }

        // Close dropdowns on outside click
        document.addEventListener('click', (e) => {
            const anyDropdown = e.target.closest('.dropdown-filter');
            const anyToggle = e.target.closest('.dropdown-filter-toggle');
            if (!anyDropdown && !anyToggle) {
                document.querySelectorAll('.dropdown-filter.open').forEach(el => el.classList.remove('open'));
            }
        });

        // Removed search and select-all/none per updated requirements

        function updateDropdownLabels() {
            // Cauldrons
            const cbsC = Array.from(document.querySelectorAll('#filter-cauldron-container input[type="checkbox"]'));
            const selectedC = cbsC.filter(cb => cb.checked).map(cb => cb.value);
            const cLabel = document.getElementById('cauldron-dropdown-label');
            cLabel.textContent = selectedC.length === cbsC.length ? 'All Cauldrons' : (selectedC.slice(0,3).join(', ') + (selectedC.length>3 ? ` +${selectedC.length-3}` : '')) || 'None';

            // Couriers
            const cbsR = Array.from(document.querySelectorAll('#filter-courier-container input[type="checkbox"]'));
            const selectedR = cbsR.filter(cb => cb.checked).map(cb => cb.value);
            const rLabel = document.getElementById('courier-dropdown-label');
            rLabel.textContent = selectedR.length === cbsR.length ? 'All Couriers' : (selectedR.slice(0,3).join(', ') + (selectedR.length>3 ? ` +${selectedR.length-3}` : '')) || 'None';

            // Status
            const cbsS = Array.from(document.querySelectorAll('#filter-status-container input[type="checkbox"]'));
            const selectedS = cbsS.filter(cb => cb.checked).map(cb => cb.value);
            const sLabel = document.getElementById('status-dropdown-label');
            const pretty = { normal: 'Normal', suspicious: 'Suspicious' };
            sLabel.textContent = selectedS.length === cbsS.length ? 'All Statuses' : (selectedS.map(v => pretty[v] || v).join(', ') || 'None');
        }
        
        let map;
        let cauldrons = [];
        let market = null;
        let network = [];
        let currentLevels = {};
        let cauldronMarkers = {};
        let allTimestamps = [];
        let filteredTimestamps = [];
        let timestampIndices = [];
        let currentIndex = 0;
        let isPlaying = false;
        let playInterval = null;
        let dateGroups = {};
        let cachedData = null; // Cache all historical data
        let isDataLoaded = false;
        let selectedTimezone = 'UTC'; // Default timezone
        
        // Ticket pagination
        let allTickets = [];
        let filteredTickets = [];
        let currentTicketPage = 1;
        let ticketsPerPage = 10;
        
        // Initialize map
        function initMap() {
            // Default center (will be updated when data loads)
            map = L.map('map').setView([33.2148, -97.13], 13);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Fetch current potion levels
        async function loadCurrentLevels() {
            try {
                const response = await fetch('/api/current-levels');
                const data = await response.json();
                
                if (data.error) {
                    console.warn('Could not load current levels:', data.error);
                    return;
                }
                
                currentLevels = data.levels || {};
                console.log('Loaded current levels:', currentLevels);
            } catch (error) {
                console.error('Error loading current levels:', error);
            }
        }
        
        // Load all historical data at once for client-side caching
        async function loadAllHistoricalData() {
            if (isDataLoaded && cachedData) {
                console.log('Using cached data');
                return true;
            }
            
            try {
                console.log('Loading full historical data... (this may take a moment)');
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Loading historical data...';
                
                const response = await fetch('/api/data-full', {
                    cache: 'force-cache' // Use browser cache if available
                });
                const result = await response.json();
                
                if (result.error) {
                    console.error('Could not load historical data:', result.error);
                    return false;
                }
                
                cachedData = result.data || [];
                console.log('Loaded and cached', cachedData.length, 'timestamps');
                
                // First pass: Calculate expected fill rates for each cauldron
                const fillRates = {}; // cauldron_id -> L/min
                const deltasByCauldron = {};
                
                // Identify periods of pure generation (no draining) to estimate fill rate
                for (let i = 1; i < cachedData.length; i++) {
                    const prev = cachedData[i-1];
                    const curr = cachedData[i];
                    const prevLevels = prev.cauldron_levels || {};
                    const currLevels = curr.cauldron_levels || {};
                    
                    Object.keys(currLevels).forEach(id => {
                        const Vprev = prevLevels[id] ?? 0;
                        const Vcurr = currLevels[id] ?? 0;
                        const delta = Vcurr - Vprev;
                        
                        // Only collect positive deltas for fill rate estimation
                        if (delta > 0) {
                            if (!deltasByCauldron[id]) deltasByCauldron[id] = [];
                            deltasByCauldron[id].push(delta);
                        }
                    });
                }
                
                // Calculate mean fill rate per cauldron
                Object.keys(deltasByCauldron).forEach(id => {
                    const deltas = deltasByCauldron[id];
                    if (deltas.length > 0) {
                        const sum = deltas.reduce((acc, val) => acc + val, 0);
                        fillRates[id] = sum / deltas.length;
                    } else {
                        fillRates[id] = 0.5; // Default fallback
                    }
                });
                
                console.log('Calculated fill rates:', fillRates);
                
                // Second pass: Detect draining using trend analysis
                // Look at 5-minute rolling window to detect abnormal fill rate
                const WINDOW_SIZE = 5; // 5 minutes
                const DRAIN_THRESHOLD = 0.4; // If actual rate < 40% of expected, it's draining
                
                for (let i = 0; i < cachedData.length; i++) {
                    const record = cachedData[i];
                    record.drainStatus = {}; // cauldron_id -> boolean
                    
                    // Need at least WINDOW_SIZE previous records to analyze trend
                    if (i >= WINDOW_SIZE) {
                        const currLevels = record.cauldron_levels || {};
                        
                        Object.keys(currLevels).forEach(cauldronId => {
                            const expectedFillRate = fillRates[cauldronId] || 0.5;
                            
                            // Calculate actual rate over the window
                            const windowStart = cachedData[i - WINDOW_SIZE];
                            const windowStartLevel = windowStart.cauldron_levels?.[cauldronId] || 0;
                            const currentLevel = currLevels[cauldronId] || 0;
                            
                            // Actual change over WINDOW_SIZE minutes
                            const actualChange = currentLevel - windowStartLevel;
                            const actualRate = actualChange / WINDOW_SIZE; // L/min
                            
                            // Expected change over WINDOW_SIZE minutes
                            const expectedChange = expectedFillRate * WINDOW_SIZE;
                            
                            // If actual rate is significantly less than expected, cauldron is being drained
                            const isDraining = actualRate < (expectedFillRate * DRAIN_THRESHOLD);
                            
                            record.drainStatus[cauldronId] = isDraining;
                        });
                    }
                }
                
                console.log('Annotated drain status using trend analysis (5-min window, 40% threshold)');
                
                // Extract timestamps for organization
                allTimestamps = cachedData.map(record => record.timestamp);
                
                // Organize timestamps by date
                organizeDateGroups();
                populateDateDropdowns();
                
                isDataLoaded = true;
                document.getElementById('loading').style.display = 'none';
                
                return true;
            } catch (error) {
                console.error('Error loading historical data:', error);
                document.getElementById('loading').textContent = 'Error loading data: ' + error.message;
                return false;
            }
        }
        
        // Load timestamps (deprecated - now using loadAllHistoricalData)
        async function loadTimestamps() {
            return await loadAllHistoricalData();
        }
        
        // Organize timestamps into year/month/day groups
        function organizeDateGroups() {
            dateGroups = {};
            
            allTimestamps.forEach((timestamp, index) => {
                const date = new Date(timestamp);
                let year, month, day;
                
                if (selectedTimezone === 'UTC') {
                    // Use UTC
                    year = date.getUTCFullYear();
                    month = date.getUTCMonth() + 1; // 1-12
                    day = date.getUTCDate();
                } else {
                    // Convert to selected timezone
                    const dateStr = date.toLocaleString('en-US', { 
                        timeZone: selectedTimezone,
                        year: 'numeric',
                        month: 'numeric',
                        day: 'numeric'
                    });
                    const parts = dateStr.split('/');
                    month = parseInt(parts[0]);
                    day = parseInt(parts[1]);
                    year = parseInt(parts[2]);
                }
                
                if (!dateGroups[year]) dateGroups[year] = {};
                if (!dateGroups[year][month]) dateGroups[year][month] = {};
                if (!dateGroups[year][month][day]) dateGroups[year][month][day] = [];
                
                dateGroups[year][month][day].push({
                    timestamp: timestamp,
                    index: index
                });
            });
            
            // Debug: Log sample day to verify all 24 hours
            const sampleYear = Object.keys(dateGroups)[0];
            if (sampleYear) {
                const sampleMonth = Object.keys(dateGroups[sampleYear])[0];
                const sampleDay = Object.keys(dateGroups[sampleYear][sampleMonth])[0];
                const dayTimestamps = dateGroups[sampleYear][sampleMonth][sampleDay];
                console.log(`Sample day ${sampleYear}-${sampleMonth}-${sampleDay} (${selectedTimezone}) has ${dayTimestamps.length} timestamps`);
                if (dayTimestamps.length > 0) {
                    console.log('First:', dayTimestamps[0].timestamp);
                    console.log('Last:', dayTimestamps[dayTimestamps.length - 1].timestamp);
                }
            }
        }
        
        // Populate year/month/day dropdowns
        function populateDateDropdowns() {
            const yearSelect = document.getElementById('year-select');
            const years = Object.keys(dateGroups).sort((a, b) => b - a);
            
            yearSelect.innerHTML = '<option value="">Select a year</option>';
            years.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            });
            
            // Select most recent year by default
            if (years.length > 0) {
                yearSelect.value = years[0];
                updateMonthDropdown(years[0]);
            }
        }
        
        // Update month dropdown based on selected year
        function updateMonthDropdown(year) {
            const monthSelect = document.getElementById('month-select');
            const monthNames = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthSelect.innerHTML = '<option value="">Select a month</option>';
            
            if (!year || !dateGroups[year]) return;
            
            const months = Object.keys(dateGroups[year]).sort((a, b) => b - a);
            months.forEach(month => {
                const option = document.createElement('option');
                option.value = month;
                option.textContent = monthNames[parseInt(month)];
                monthSelect.appendChild(option);
            });
            
            // Select most recent month by default
            if (months.length > 0) {
                monthSelect.value = months[0];
                updateDayDropdown(year, months[0]);
            }
        }
        
        // Update day dropdown based on selected year and month
        function updateDayDropdown(year, month) {
            const daySelect = document.getElementById('day-select');
            
            daySelect.innerHTML = '<option value="">Select a day</option>';
            
            if (!year || !month || !dateGroups[year] || !dateGroups[year][month]) return;
            
            const days = Object.keys(dateGroups[year][month]).sort((a, b) => b - a);
            days.forEach(day => {
                const option = document.createElement('option');
                option.value = day;
                option.textContent = day;
                daySelect.appendChild(option);
            });
            
            // Select most recent day by default
            if (days.length > 0) {
                daySelect.value = days[0];
            }
        }
        
        // Filter timestamps for selected date
        function filterTimestampsForDate(year, month, day) {
            if (!year || !month || !day || !dateGroups[year] || !dateGroups[year][month] || !dateGroups[year][month][day]) {
                return [];
            }
            
            return dateGroups[year][month][day];
        }
        
        // Update time slider for selected date
        function updateTimeSlider() {
            const year = document.getElementById('year-select').value;
            const month = document.getElementById('month-select').value;
            const day = document.getElementById('day-select').value;
            
            const dayData = filterTimestampsForDate(year, month, day);
            filteredTimestamps = dayData;
            
            const slider = document.getElementById('time-slider');
            slider.max = dayData.length - 1;
            slider.value = dayData.length - 1;
            slider.disabled = dayData.length === 0;
            
            if (dayData.length > 0) {
                currentIndex = dayData.length - 1;
                updateTimestampDisplay();
            }
        }
        
        // Show data for selected date/time
        async function showSelectedData() {
            const year = document.getElementById('year-select').value;
            const month = document.getElementById('month-select').value;
            const day = document.getElementById('day-select').value;
            
            if (!year || !month || !day) {
                alert('Please select a year, month, and day');
                return;
            }
            
            updateTimeSlider();
            
            if (filteredTimestamps.length > 0) {
                const sliderIndex = parseInt(document.getElementById('time-slider').value);
                const actualIndex = filteredTimestamps[sliderIndex].index;
                await loadLevelsAtIndex(actualIndex);
            }
        }
        
        // Load levels at specific index (original function remains the same)
        // Load levels at specific index (now using cached data)
        function loadLevelsAtIndex(index) {
            try {
                // Use cached data instead of API call
                if (!cachedData || index < 0 || index >= cachedData.length) {
                    console.error('Invalid index or data not loaded:', index);
                    return false;
                }
                
                const record = cachedData[index];
                currentLevels = record.cauldron_levels || {};
                
                updateCauldronMarkers();
                updateStats();
                
                return true;
            } catch (error) {
                console.error('Error loading levels at index:', error);
                return false;
            }
        }
        
        // Update timestamp display
        function updateTimestampDisplay() {
            if (!filteredTimestamps || filteredTimestamps.length === 0) return;
            
            const sliderIndex = parseInt(document.getElementById('time-slider').value);
            if (sliderIndex < 0 || sliderIndex >= filteredTimestamps.length) return;
            
            const timestamp = filteredTimestamps[sliderIndex].timestamp;
            const date = new Date(timestamp);
            
            const options = {
                month: 'short', 
                day: 'numeric', 
                year: 'numeric',
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit',
                timeZone: selectedTimezone,
                timeZoneName: 'short'
            };
            
            document.getElementById('current-timestamp').textContent = 
                date.toLocaleString('en-US', options);
        }
        
        // Update cauldron markers with new data
        function updateCauldronMarkers() {
            cauldrons.forEach(cauldron => {
                const marker = cauldronMarkers[cauldron.id];
                if (!marker) return;
                
                const maxVolume = cauldron.max_volume || 1000;
                const currentVolume = currentLevels[cauldron.id] || 0;
                const fillPercent = ((currentVolume / maxVolume) * 100).toFixed(1);
                const name = cauldron.name || cauldron.id;
                
                // Update marker icon using PNG with glow
                const icon = getCauldronIcon(parseFloat(fillPercent));
                marker.setIcon(icon);
                
                // Update popup
                marker.setPopupContent(`
                    <b>${name}</b><br>
                    ID: ${cauldron.id}<br>
                    <b>Current: ${currentVolume.toFixed(1)}L / ${maxVolume}L</b><br>
                    <b>Fill Level: ${fillPercent}%</b><br>
                    Location: ${cauldron.latitude.toFixed(4)}, ${cauldron.longitude.toFixed(4)}
                `);
                
                // Update tooltip
                marker.setTooltipContent(`${name}<br>${fillPercent}%`);
            });
            
            // Update bar chart
            updateBarChart();
        }
        
        // Update bar chart with current cauldron levels
        function updateBarChart() {
            const barChart = document.getElementById('cauldron-bar-chart');
            if (!barChart || !cauldrons || cauldrons.length === 0) return;
            
            // Get current slider index to check for draining
            const sliderIndex = parseInt(document.getElementById('time-slider').value);
            
            // filteredTimestamps contains {timestamp, index} objects
            const currentEntry = filteredTimestamps?.[sliderIndex];
            if (!currentEntry) return;
            
            const globalIndex = currentEntry.index;
            const currentRecord = cachedData?.[globalIndex];
            if (!currentRecord) return;
            
            const drainStatus = currentRecord.drainStatus || {};
            
            barChart.innerHTML = '';
            
            cauldrons.forEach(cauldron => {
                const maxVolume = cauldron.max_volume || 1000;
                const currentVolume = currentLevels[cauldron.id] || 0;
                const fillPercent = ((currentVolume / maxVolume) * 100).toFixed(1);
                
                // Use pre-calculated drain status
                const isDraining = drainStatus[cauldron.id] || false;
                
                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                
                const bar = document.createElement('div');
                bar.className = `bar${isDraining ? ' draining' : ''}`;
                // Use 80% of available height for the bar area, scale fillPercent accordingly
                bar.style.height = `${Math.max(fillPercent * 0.8, 2)}%`;
                bar.title = `${cauldron.name || cauldron.id}: ${fillPercent}%${isDraining ? ' (DRAINING)' : ''}`;
                
                const value = document.createElement('div');
                value.className = 'bar-value';
                value.textContent = `${fillPercent}%`;
                
                const label = document.createElement('div');
                label.className = 'bar-label';
                label.textContent = cauldron.name || cauldron.id;
                
                barItem.appendChild(bar);
                barItem.appendChild(value);
                barItem.appendChild(label);
                barChart.appendChild(barItem);
            });
        }
        
        // Fetch current potion levels (original function - now used for initial load)
        async function loadInitialCurrentLevels() {
            try {
                const response = await fetch('/api/current-levels');
                const data = await response.json();
                
                if (data.error) {
                    console.warn('Could not load current levels:', data.error);
                    return;
                }
                
                currentLevels = data.levels || {};
                console.log('Loaded current levels:', currentLevels);
            } catch (error) {
                console.error('Error loading current levels:', error);
            }
        }
        
        // Fetch and display cauldrons
        async function loadCauldrons() {
            try {
                const response = await fetch('/api/cauldrons');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                cauldrons = data;
                console.log('Loaded cauldrons:', cauldrons);
                
                // Add cauldron markers (will be updated by timeline)
                cauldrons.forEach(cauldron => {
                    const lat = cauldron.latitude;
                    const lon = cauldron.longitude;
                    const name = cauldron.name || cauldron.id;
                    const maxVolume = cauldron.max_volume || 1000;
                    
                    // Start with default icon
                    const currentVolume = 0;
                    const fillPercent = 0;
                    
                    // Determine color based on fill level
                    let markerColor = 'üß™'; // Default blue
                    if (fillPercent > 90) {
                        markerColor = 'üî¥'; // Red - almost full
                    } else if (fillPercent > 70) {
                        markerColor = 'üü†'; // Orange - getting full
                    } else if (fillPercent > 50) {
                        markerColor = 'üü°'; // Yellow - half full
                    } else {
                        markerColor = 'üîµ'; // Blue - plenty of space
                    }
                    
                    // Create PNG icon with default (blue) glow
                    const icon = getCauldronIcon(fillPercent);
                    
                    // Add marker
                    const marker = L.marker([lat, lon], { icon: icon }).addTo(map);
                    
                    // Store marker reference
                    cauldronMarkers[cauldron.id] = marker;
                    
                    // Add popup with current level info
                    marker.bindPopup(`
                        <b>${name}</b><br>
                        ID: ${cauldron.id}<br>
                        <b>Current: ${currentVolume.toFixed(1)}L / ${maxVolume}L</b><br>
                        <b>Fill Level: ${fillPercent}%</b><br>
                        Location: ${lat.toFixed(4)}, ${lon.toFixed(4)}
                    `);
                    
                    // Add tooltip that only shows on hover
                    marker.bindTooltip(`${name}<br>${fillPercent}%`, {
                        permanent: false,
                        direction: 'top',
                        className: 'cauldron-label',
                        offset: [0, -15]
                    });
                });
                
                return true;
            } catch (error) {
                console.error('Error loading cauldrons:', error);
                document.getElementById('loading').innerHTML = 
                    `<div class="error">Error loading cauldrons: ${error.message}</div>`;
                return false;
            }
        }
        
        // Fetch and display market
        async function loadMarket() {
            try {
                const response = await fetch('/api/market');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                market = data;
                console.log('Loaded market:', market);
                
                const lat = market.latitude;
                const lon = market.longitude;
                const name = market.name || 'Enchanted Market';
                
                // Create custom market icon using PNG
                const icon = L.icon({
                    iconUrl: '/static/images/markers/market.png',
                    iconSize: [50, 50],
                    iconAnchor: [25, 25],
                    popupAnchor: [0, -25]
                });
                
                // Add marker
                const marker = L.marker([lat, lon], { icon: icon }).addTo(map);
                
                // Add popup
                marker.bindPopup(`
                    <b>${name}</b><br>
                    ID: ${market.id}<br>
                    Central Trading Hub<br>
                    Location: ${lat.toFixed(4)}, ${lon.toFixed(4)}
                `);
                
                // Add tooltip that only shows on hover
                marker.bindTooltip(name, {
                    permanent: false,
                    direction: 'top',
                    className: 'market-label',
                    offset: [0, -20]
                });
                
                return true;
            } catch (error) {
                console.error('Error loading market:', error);
                return false;
            }
        }
        
        // Fetch and display network connections
        async function loadNetwork() {
            try {
                const response = await fetch('/api/network');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                network = data.edges || data;
                console.log('Loaded network (raw):', network);
                
                // Normalize network edge property names
                if (network && network.length > 0) {
                    console.log('Sample edge:', network[0]);
                    network = network.map(edge => ({
                        from_node: edge.from_node || edge.from || edge.source || edge.start,
                        to_node: edge.to_node || edge.to || edge.target || edge.end,
                        travel_time_minutes: edge.travel_time_minutes || edge.travel_time || edge.time || edge.duration || 0
                    }));
                    console.log('Normalized network:', network.slice(0, 3));
                }
                
                console.log('Loaded network:', network);
                
                // We'll need cauldron and market coordinates to draw lines
                const coords = {};
                
                // Map cauldron IDs to coordinates
                cauldrons.forEach(c => {
                    coords[c.id] = [c.latitude, c.longitude];
                });
                
                // Add market coordinates
                if (market) {
                    coords[market.id] = [market.latitude, market.longitude];
                    coords['MARKET'] = [market.latitude, market.longitude];
                    coords['market_001'] = [market.latitude, market.longitude];
                }
                
                // Draw connections
                network.forEach(edge => {
                    const fromCoords = coords[edge.from];
                    const toCoords = coords[edge.to];
                    
                    if (fromCoords && toCoords) {
                        const isMarketConnection = 
                            edge.from === 'MARKET' || edge.from === market?.id ||
                            edge.to === 'MARKET' || edge.to === market?.id;
                        
                        const travelTime = edge.travel_time_minutes || edge.travel_time || null;
                        const distance = edge.distance || edge.distance_km || null;
                        
                        // Draw the line
                        const line = L.polyline([fromCoords, toCoords], {
                            color: isMarketConnection ? '#ff6b6b' : '#667eea',
                            weight: 2,
                            opacity: 0.6
                        }).addTo(map);
                        
                        // Add popup with detailed info
                        let popupContent = `<b>${edge.from} ‚Üí ${edge.to}</b><br>`;
                        if (travelTime) popupContent += `‚è±Ô∏è Travel Time: ${travelTime} min<br>`;
                        if (distance) popupContent += `üìè Distance: ${distance} km<br>`;
                        line.bindPopup(popupContent);
                        
                        // Add permanent label with travel time at midpoint
                        if (travelTime) {
                            const midLat = (fromCoords[0] + toCoords[0]) / 2;
                            const midLon = (fromCoords[1] + toCoords[1]) / 2;
                            
                            L.marker([midLat, midLon], {
                                icon: L.divIcon({
                                    className: 'edge-label',
                                    html: `<div style="
                                        background: rgba(255,255,255,0.9);
                                        padding: 2px 6px;
                                        border-radius: 4px;
                                        font-size: 11px;
                                        font-weight: 600;
                                        color: ${isMarketConnection ? '#c92a2a' : '#4c5fd5'};
                                        border: 1px solid ${isMarketConnection ? '#ff6b6b' : '#667eea'};
                                        white-space: nowrap;
                                        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                                    ">${travelTime} min</div>`,
                                    iconSize: [60, 20],
                                    iconAnchor: [30, 10]
                                })
                            }).addTo(map);
                        }
                    }
                });
                
                return true;
            } catch (error) {
                console.error('Error loading network:', error);
                return false;
            }
        }
        
        // Update statistics
        function updateStats() {
            const totalCapacity = cauldrons.reduce((sum, c) => sum + (c.max_volume || 1000), 0);
            const totalCurrent = Object.values(currentLevels).reduce((sum, level) => sum + level, 0);
            const avgFillPercent = totalCapacity > 0 ? ((totalCurrent / totalCapacity) * 100).toFixed(1) : 0;
            
            const statsHtml = `
                <div class="stat-card">
                    <h3>${cauldrons.length}</h3>
                    <p>Total Cauldrons</p>
                </div>
                <div class="stat-card">
                    <h3>${totalCurrent.toFixed(0)}L</h3>
                    <p>Current Total Volume</p>
                </div>
                <div class="stat-card">
                    <h3>${avgFillPercent}%</h3>
                    <p>Average Fill Level</p>
                </div>
                <div class="stat-card">
                    <h3>${network.length}</h3>
                    <p>Network Connections</p>
                </div>
                <div class="stat-card">
                    <h3>${totalCapacity}L</h3>
                    <p>Total Capacity</p>
                </div>
            `;
            document.getElementById('stats').innerHTML = statsHtml;
        }
        
        // Center map on all markers
        function centerMap() {
            const bounds = [];
            
            cauldrons.forEach(c => {
                bounds.push([c.latitude, c.longitude]);
            });
            
            if (market) {
                bounds.push([market.latitude, market.longitude]);
            }
            
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
        
        // Timeline control functions
        function setupTimelineControls() {
            const slider = document.getElementById('time-slider');
            const btnShow = document.getElementById('btn-show');
            const btnFirst = document.getElementById('btn-first');
            const btnPrev = document.getElementById('btn-prev');
            const btnPlay = document.getElementById('btn-play');
            const btnNext = document.getElementById('btn-next');
            const btnLast = document.getElementById('btn-last');
            const yearSelect = document.getElementById('year-select');
            const monthSelect = document.getElementById('month-select');
            const daySelect = document.getElementById('day-select');
            const timezoneSelect = document.getElementById('timezone-select');
            
            // Timezone change - reorganize all data
            timezoneSelect.addEventListener('change', function() {
                selectedTimezone = this.value;
                console.log('Timezone changed to:', selectedTimezone);
                
                // Reorganize date groups with new timezone
                organizeDateGroups();
                populateDateDropdowns();
                
                // Update display if a date is selected
                if (filteredTimestamps.length > 0) {
                    updateTimestampDisplay();
                }
            });
            
            // Date dropdown changes
            yearSelect.addEventListener('change', function() {
                updateMonthDropdown(this.value);
            });
            
            monthSelect.addEventListener('change', function() {
                const year = yearSelect.value;
                updateDayDropdown(year, this.value);
            });
            
            // Show button
            btnShow.addEventListener('click', showSelectedData);
            
            // Time slider change
            slider.addEventListener('input', function() {
                updateTimestampDisplay();
            });
            
            slider.addEventListener('change', async function() {
                if (filteredTimestamps.length > 0) {
                    const sliderIndex = parseInt(this.value);
                    const actualIndex = filteredTimestamps[sliderIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                }
            });
            
            // First button
            btnFirst.addEventListener('click', async function() {
                if (filteredTimestamps.length > 0) {
                    slider.value = 0;
                    const actualIndex = filteredTimestamps[0].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Previous button
            btnPrev.addEventListener('click', async function() {
                const sliderIndex = parseInt(slider.value);
                const newIndex = Math.max(0, sliderIndex - 1);
                slider.value = newIndex;
                if (filteredTimestamps.length > 0) {
                    const actualIndex = filteredTimestamps[newIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Play/Pause button
            btnPlay.addEventListener('click', function() {
                if (isPlaying) {
                    stopPlayback();
                } else {
                    startPlayback();
                }
            });
            
            // Next button
            btnNext.addEventListener('click', async function() {
                const sliderIndex = parseInt(slider.value);
                const newIndex = Math.min(filteredTimestamps.length - 1, sliderIndex + 1);
                slider.value = newIndex;
                if (filteredTimestamps.length > 0) {
                    const actualIndex = filteredTimestamps[newIndex].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
            
            // Last button
            btnLast.addEventListener('click', async function() {
                if (filteredTimestamps.length > 0) {
                    slider.value = filteredTimestamps.length - 1;
                    const actualIndex = filteredTimestamps[filteredTimestamps.length - 1].index;
                    await loadLevelsAtIndex(actualIndex);
                    updateTimestampDisplay();
                }
            });
        }
        
        function startPlayback() {
            if (filteredTimestamps.length === 0) return;
            
            isPlaying = true;
            document.getElementById('btn-play').textContent = '‚è∏Ô∏è Pause';
            
            const slider = document.getElementById('time-slider');
            
            playInterval = setInterval(async () => {
                const sliderIndex = parseInt(slider.value);
                if (sliderIndex >= filteredTimestamps.length - 1) {
                    stopPlayback();
                    return;
                }
                
                const newIndex = sliderIndex + 1;
                slider.value = newIndex;
                const actualIndex = filteredTimestamps[newIndex].index;
                await loadLevelsAtIndex(actualIndex);
                updateTimestampDisplay();
            }, 100); // Play at 10 timestamps per second (100ms each)
        }
        
        function stopPlayback() {
            isPlaying = false;
            document.getElementById('btn-play').textContent = '‚ñ∂Ô∏è Play';
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }
        
        // Load tickets from API
        async function loadTickets() {
            try {
                const response = await fetch('/api/tickets');
                const data = await response.json();
                
                if (data.error) {
                    console.error('Could not load tickets:', data.error);
                    document.getElementById('ticket-loading').textContent = 'Error loading tickets';
                    return false;
                }
                
                // API returns {metadata, transport_tickets}
                allTickets = data.transport_tickets || [];
                filteredTickets = [...allTickets]; // Initialize filtered tickets
                
                console.log('Loaded', allTickets.length, 'tickets');
                console.log('Metadata:', data.metadata);
                console.log('Sample ticket:', allTickets[0]);
                
                populateFilterDropdowns();
                // If historical data already loaded compute discrepancies now
                if (cachedData && cachedData.length) {
                    computeDailyDrainEvents();
                    annotateTicketDiscrepancies();
                }
                displayTickets();
                document.getElementById('ticket-loading').style.display = 'none';
                document.getElementById('ticket-container').style.display = 'block';
                
                return true;
            } catch (error) {
                console.error('Error loading tickets:', error);
                document.getElementById('ticket-loading').textContent = 'Error loading tickets';
                return false;
            }
        }

        // Map: date -> cauldron_id -> [drain events]
        let dailyDrainEvents = {};
    // Map: cauldron_id -> estimated fill_rate (L/min) calculated from data
    let cauldronFillRates = {};
    // Map: cauldron_id -> estimated drain_rate (L/min) calculated from drain sessions
    let cauldronDrainRates = {};

        // Step 1: Estimate fill rates from historical data by analyzing positive deltas
        // Only use data from stable generation periods (not during drains)
        function estimateFillRates() {
            cauldronFillRates = {};
            if (!cachedData || cachedData.length < 2) return;
            
            const deltasByCauldron = {}; // cauldron_id -> [positive deltas during generation]
            
            // First pass: identify drain periods (consecutive negative deltas)
            const isDraining = {}; // index -> cauldron_id -> boolean
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                
                if (!isDraining[i]) isDraining[i] = {};
                if (!isDraining[i-1]) isDraining[i-1] = {};
                
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    
                    // Mark as draining if negative delta
                    if (delta < -0.1) {
                        isDraining[i][id] = true;
                        isDraining[i-1][id] = true; // Mark previous point too
                        // Also mark next few points to avoid drain tail effects
                        if (isDraining[i+1]) isDraining[i+1][id] = true;
                        if (isDraining[i+2]) isDraining[i+2][id] = true;
                    }
                });
            }
            
            // Second pass: collect positive deltas ONLY from non-drain periods
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    
                    // Only collect positive deltas when NOT draining
                    if (delta > 0 && !isDraining[i]?.[id] && !isDraining[i-1]?.[id]) {
                        if (!deltasByCauldron[id]) deltasByCauldron[id] = [];
                        deltasByCauldron[id].push(delta);
                    }
                });
            }
            
            // Calculate average (mean) positive delta as fill_rate estimate (L/min)
            // Using mean instead of median for more stable rate estimation
            Object.keys(deltasByCauldron).forEach(id => {
                const deltas = deltasByCauldron[id];
                if (deltas.length === 0) {
                    cauldronFillRates[id] = 1.0; // Fallback
                    return;
                }
                const sum = deltas.reduce((acc, val) => acc + val, 0);
                const mean = sum / deltas.length;
                cauldronFillRates[id] = mean;
            });
            
            console.log('Estimated fill rates (L/min) from non-drain periods:', cauldronFillRates);
            Object.keys(cauldronFillRates).forEach(id => {
                const rate = cauldronFillRates[id];
                const sampleCount = deltasByCauldron[id]?.length || 0;
                console.log(`  ${id}: ${rate.toFixed(3)} L/min (${sampleCount} samples)`);
            });
        }

        // Step 2: Detect individual drain events and store them
        // Each drain event = one pickup session (~15 minutes of continuous decline)
        function computeDailyDrainEvents() {
            dailyDrainEvents = {};
            if (!cachedData || !cachedData.length) return;
            
            // First estimate fill rates from the data
            estimateFillRates();
            
            const drainRatesByCauldron = {}; // cauldron_id -> [session drain rates]
            
            // Group data by date and cauldron
            const seriesByDateCauldron = {}; // date -> cauldron -> [{timestamp, level, delta}]
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                const dateStr = new Date(curr.timestamp).toISOString().slice(0,10);
                if (!seriesByDateCauldron[dateStr]) seriesByDateCauldron[dateStr] = {};
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const Vprev = prevLevels[id] ?? 0;
                    const Vcurr = currLevels[id] ?? 0;
                    const delta = Vcurr - Vprev;
                    if (!seriesByDateCauldron[dateStr][id]) seriesByDateCauldron[dateStr][id] = [];
                    seriesByDateCauldron[dateStr][id].push({timestamp: curr.timestamp, level: Vcurr, prevLevel: Vprev, delta});
                });
            }
            
            // Detect individual drain events (sessions): continuous negative deltas
            Object.keys(seriesByDateCauldron).forEach(dateStr => {
                if (!dailyDrainEvents[dateStr]) dailyDrainEvents[dateStr] = {};
                Object.keys(seriesByDateCauldron[dateStr]).forEach(id => {
                    const series = seriesByDateCauldron[dateStr][id];
                    let sessionStart = null;
                    let sessionStartLevel = 0;
                    let sessionEndLevel = 0;
                    let sessionStartTime = null;
                    let sessionEndTime = null;
                    const events = [];
                    
                    for (let i = 0; i < series.length; i++) {
                        const pt = series[i];
                        if (pt.delta < -0.1) { // Negative delta = drain (use threshold to avoid noise)
                            // Drain detected
                            if (sessionStart === null) {
                                // Start new drain session
                                sessionStart = i;
                                sessionStartLevel = pt.prevLevel; // Level before drain started
                                sessionStartTime = pt.timestamp;
                            }
                            sessionEndLevel = pt.level; // Current level
                            sessionEndTime = pt.timestamp;
                        } else {
                            // Not draining - close session if one was active
                            if (sessionStart !== null) {
                                // Session ended - calculate VTrue for this drain event using actual duration
                                const fillRate = cauldronFillRates[id] ?? 1.0;
                                const drainedRaw = sessionStartLevel - sessionEndLevel;
                                const durationMin = (i - sessionStart); // consecutive minutes
                                const VTrue = drainedRaw + (fillRate * durationMin);
                                const drainRate = durationMin > 0 ? (VTrue / durationMin) : null; // L/min
                                events.push({
                                    startTime: sessionStartTime,
                                    startLevel: sessionStartLevel,
                                    endLevel: sessionEndLevel,
                                    drainedRaw: drainedRaw,
                                    VTrue: VTrue,
                                    durationMin: durationMin,
                                    drainRate: drainRate,
                                    fillRate: fillRate,
                                    matched: false,
                                    matchedTicket: null
                                });
                                if (drainRate && isFinite(drainRate)) {
                                    if (!drainRatesByCauldron[id]) drainRatesByCauldron[id] = [];
                                    drainRatesByCauldron[id].push(drainRate);
                                }
                                sessionStart = null;
                                sessionEndTime = null;
                            }
                        }
                    }
                    // Close last session if still active at end of day
                    if (sessionStart !== null) {
                        const fillRate = cauldronFillRates[id] ?? 1.0;
                        const drainedRaw = sessionStartLevel - sessionEndLevel;
                        const durationMin = (series.length - sessionStart);
                        const VTrue = drainedRaw + (fillRate * durationMin);
                        const drainRate = durationMin > 0 ? (VTrue / durationMin) : null;
                        events.push({
                            startTime: sessionStartTime,
                            startLevel: sessionStartLevel,
                            endLevel: sessionEndLevel,
                            drainedRaw: drainedRaw,
                            VTrue: VTrue,
                            durationMin: durationMin,
                            drainRate: drainRate,
                            fillRate: fillRate,
                            matched: false,
                            matchedTicket: null
                        });
                        if (drainRate && isFinite(drainRate)) {
                            if (!drainRatesByCauldron[id]) drainRatesByCauldron[id] = [];
                            drainRatesByCauldron[id].push(drainRate);
                        }
                    }
                    
                    if (events.length > 0) {
                        dailyDrainEvents[dateStr][id] = events;
                    }
                });
            });
            // Aggregate drain rates per cauldron (median for robustness)
            cauldronDrainRates = {};
            Object.keys(drainRatesByCauldron).forEach(id => {
                const arr = drainRatesByCauldron[id].slice().sort((a,b)=>a-b);
                const mid = Math.floor(arr.length/2);
                const median = arr.length % 2 ? arr[mid] : (arr[mid-1] + arr[mid]) / 2;
                cauldronDrainRates[id] = median;
            });
            console.log('Detected individual drain events per day/cauldron:', dailyDrainEvents);
            console.log('Estimated drain rates (L/min) from drain sessions (median):', cauldronDrainRates);
        }

        // Re-annotate each timestamp's drainStatus using learned fill and drain rates
        function reAnnotateDrainStatusUsingRates() {
            if (!cachedData || cachedData.length < 2) return;
            for (let i = 1; i < cachedData.length; i++) {
                const prev = cachedData[i-1];
                const curr = cachedData[i];
                const prevLevels = prev.cauldron_levels || {};
                const currLevels = curr.cauldron_levels || {};
                if (!curr.drainStatus) curr.drainStatus = {};
                const ids = new Set([...Object.keys(prevLevels), ...Object.keys(currLevels)]);
                ids.forEach(id => {
                    const fr = cauldronFillRates[id] ?? 0.5;
                    const dr = cauldronDrainRates[id] ?? (fr * 2); // fallback: assume drains roughly 2x fill
                    const net = (currLevels[id] ?? 0) - (prevLevels[id] ?? 0);
                    // Thresholds
                    const slowFillThreshold = fr * 0.4; // below 40% of expected fill is suspicious
                    const drainNetExpected = fr - dr; // typically negative
                    const drainThreshold = Math.min(slowFillThreshold, drainNetExpected * 0.6); // allow tolerance
                    const isDraining = net < drainThreshold;
                    curr.drainStatus[id] = !!isDraining;
                });
            }
            console.log('Re-annotated drainStatus using fill/drain rates');
        }

        // Match tickets to drain events and annotate with discrepancy status
        function annotateTicketDiscrepancies() {
            if (!allTickets || !allTickets.length) return;
            const TOLERANCE = 0.20; // 20% tolerance to account for measurement noise and timing differences
            
            console.log('=== TICKET-TO-DRAIN MATCHING ===');
            
            // Track discrepancy distribution for analysis
            const discrepancies = [];
            let totalTickets = 0;
            let matchCount = 0;
            let overCount = 0;
            let underCount = 0;
            let noDataCount = 0;
            let unmatchedCount = 0;
            
            // Group tickets by date and cauldron
            const ticketsByDateCauldron = {};
            allTickets.forEach(t => {
                // Normalize date format to YYYY-MM-DD
                let normalizedDate = t.date;
                if (normalizedDate && normalizedDate.includes('T')) {
                    // If date has time component, extract just the date part
                    normalizedDate = normalizedDate.slice(0, 10);
                }
                const key = `${normalizedDate}|${t.cauldron_id}`;
                if (!ticketsByDateCauldron[key]) ticketsByDateCauldron[key] = [];
                ticketsByDateCauldron[key].push(t);
            });
            
            console.log('Ticket date/cauldron keys:', Object.keys(ticketsByDateCauldron).slice(0, 10));
            console.log('Drain event dates:', Object.keys(dailyDrainEvents));
            
            // For each date/cauldron combo, match tickets to drain events
            Object.keys(ticketsByDateCauldron).forEach(key => {
                const [date, cauldronId] = key.split('|');
                const tickets = ticketsByDateCauldron[key];
                const drainEvents = dailyDrainEvents?.[date]?.[cauldronId] || [];
                
                if (drainEvents.length === 0) {
                    // No drain data - mark all tickets as no-data
                    console.log(`‚ö†Ô∏è No drain events found for ${date} | ${cauldronId} (${tickets.length} tickets)`);
                    tickets.forEach(t => {
                        t.discrepancy_status = 'no-data';
                        t.discrepancy_diff = null;
                        t.pct_discrepancy = null;
                        t.matched_drain = null;
                        noDataCount++;
                        totalTickets++;
                    });
                    return;
                }
                
                // Create a copy of drain events to track which are matched
                const availableDrains = drainEvents.map((d, idx) => ({...d, idx}));
                
                // Sort tickets by amount (largest first) for better matching
                const sortedTickets = [...tickets].sort((a, b) => b.amount_collected - a.amount_collected);
                
                // Match each ticket to the closest available drain event
                sortedTickets.forEach(ticket => {
                    totalTickets++;
                    const VTicket = ticket.amount_collected || 0;
                    
                    // Find best matching drain event (closest VTrue to VTicket)
                    let bestMatch = null;
                    let bestDiff = Infinity;
                    let bestIdx = -1;
                    
                    availableDrains.forEach((drain, idx) => {
                        if (!drain.matched) {
                            const diff = Math.abs(drain.VTrue - VTicket);
                            if (diff < bestDiff) {
                                bestDiff = diff;
                                bestMatch = drain;
                                bestIdx = idx;
                            }
                        }
                    });
                    
                    if (bestMatch) {
                        // Mark drain as matched
                        availableDrains[bestIdx].matched = true;
                        drainEvents[bestMatch.idx].matched = true;
                        drainEvents[bestMatch.idx].matchedTicket = ticket.ticket_id;
                        
                        const VActual = bestMatch.VTrue;
                        const diff = VTicket - VActual;
                        const pctDisc = diff / VActual;
                        
                        ticket.discrepancy_diff = diff;
                        ticket.pct_discrepancy = pctDisc;
                        ticket.matched_drain = bestMatch.idx;
                        ticket.drain_VTrue = VActual;
                        
                        // Track all discrepancies for distribution analysis
                        discrepancies.push({
                            ticket_id: ticket.ticket_id,
                            pct: Math.abs(pctDisc),
                            diff: diff
                        });
                        
                        // Apply tolerance check
                        if (Math.abs(pctDisc) <= TOLERANCE) {
                            ticket.discrepancy_status = 'match';
                            matchCount++;
                        } else if (VTicket > VActual) {
                            ticket.discrepancy_status = 'over-reported';
                            overCount++;
                            console.log(`üö® OVER: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | VDrain: ${VActual.toFixed(2)}L | FillRate: ${bestMatch.fillRate.toFixed(2)}L/min | Diff: ${diff.toFixed(2)}L (${(pctDisc*100).toFixed(1)}%)`);
                        } else {
                            ticket.discrepancy_status = 'under-reported';
                            underCount++;
                            console.log(`üü° UNDER: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | VDrain: ${VActual.toFixed(2)}L | FillRate: ${bestMatch.fillRate.toFixed(2)}L/min | Diff: ${diff.toFixed(2)}L (${(pctDisc*100).toFixed(1)}%)`);
                        }
                    } else {
                        // No drain event to match - suspicious (ticket without corresponding drain)
                        ticket.discrepancy_status = 'no-drain-match';
                        ticket.discrepancy_diff = null;
                        ticket.pct_discrepancy = null;
                        ticket.matched_drain = null;
                        unmatchedCount++;
                        console.log(`‚ö†Ô∏è NO MATCH: Ticket ${ticket.ticket_id} | ${cauldronId} | VTicket: ${VTicket.toFixed(2)}L | No corresponding drain event found`);
                    }
                });
                
                // Log unmatched drain events (drains without tickets - potential missing tickets)
                availableDrains.forEach((drain, idx) => {
                    if (!drain.matched) {
                        console.log(`üìã UNMATCHED DRAIN: ${date} | ${cauldronId} | VDrain: ${drain.VTrue.toFixed(2)}L | No corresponding ticket found`);
                    }
                });
            });
            
            console.log(`\nSUMMARY: ${totalTickets} tickets | ‚úÖ ${matchCount} match | üö® ${overCount} over | üü° ${underCount} under | ‚ö†Ô∏è ${unmatchedCount} no-drain | ‚ùì ${noDataCount} no-data`);
            console.log(`Suspicious rate: ${((overCount + underCount + unmatchedCount) / totalTickets * 100).toFixed(1)}% (${overCount + underCount + unmatchedCount}/${totalTickets})`);
            
            // Log discrepancy distribution
            if (discrepancies.length > 0) {
                discrepancies.sort((a, b) => a.pct - b.pct);
                const percentiles = [0.25, 0.50, 0.75, 0.90, 0.95];
                console.log('\nDiscrepancy Distribution (% difference):');
                percentiles.forEach(p => {
                    const idx = Math.floor(discrepancies.length * p);
                    const val = discrepancies[idx]?.pct || 0;
                    console.log(`  ${(p*100).toFixed(0)}th percentile: ${(val*100).toFixed(1)}%`);
                });
                const maxDisc = discrepancies[discrepancies.length - 1];
                console.log(`  Max: ${(maxDisc.pct*100).toFixed(1)}% (Ticket ${maxDisc.ticket_id})`);
            }
        }

        // Extend suspicious logic to include excess/deficit discrepancies
        // Flag tickets as suspicious per spec: over/under-reported beyond tolerance
        function isTicketSuspicious(ticket) {
            if (ticket.is_suspicious || ticket.suspicious) return true;
            // Per spec: OVER-REPORTED and UNDER-REPORTED are both flagged
            if (ticket.discrepancy_status === 'over-reported' || ticket.discrepancy_status === 'under-reported') return true;
            return false;
        }
        
        // Populate filter checkboxes with unique values
        function populateFilterDropdowns() {
            const cauldrons = [...new Set(allTickets.map(t => t.cauldron_id))].sort();
            const couriers = [...new Set(allTickets.map(t => t.courier_id))].sort();
            
            const cauldronContainer = document.getElementById('filter-cauldron-container');
            cauldrons.forEach(cauldron => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = cauldron;
                checkbox.id = `cauldron-${cauldron}`;
                checkbox.checked = true;
                checkbox.onchange = function(){ applyFiltersAndSort(); updateDropdownLabels(); };

                const labelEl = document.createElement('label');
                labelEl.setAttribute('for', checkbox.id);
                labelEl.textContent = cauldron;

                item.appendChild(checkbox);
                item.appendChild(labelEl);
                cauldronContainer.appendChild(item);
            });
            
            const courierContainer = document.getElementById('filter-courier-container');
            couriers.forEach(courier => {
                const item = document.createElement('div');
                item.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = courier;
                checkbox.id = `courier-${courier}`;
                checkbox.checked = true;
                checkbox.onchange = function(){ applyFiltersAndSort(); updateDropdownLabels(); };

                const labelEl = document.createElement('label');
                labelEl.setAttribute('for', checkbox.id);
                labelEl.textContent = courier;

                item.appendChild(checkbox);
                item.appendChild(labelEl);
                courierContainer.appendChild(item);
            });
            updateDropdownLabels();
        }
        
        // Apply filters and sorting
        function applyFiltersAndSort() {
            const sortBy = document.getElementById('sort-by').value;
            // Get selected cauldrons
            const selectedCauldrons = Array.from(document.querySelectorAll('#filter-cauldron-container input:checked'))
                .map(cb => cb.value);
            
            // Get selected couriers
            const selectedCouriers = Array.from(document.querySelectorAll('#filter-courier-container input:checked'))
                .map(cb => cb.value);
            
            const filterDate = document.getElementById('filter-date').value;
            
            // Get selected statuses
            const selectedStatuses = Array.from(document.querySelectorAll('#filter-status-container input:checked'))
                .map(cb => cb.value);
            
            // Start with all tickets
            filteredTickets = [...allTickets];
            
            // Apply cauldron filter (if any selected)
            if (selectedCauldrons.length > 0) {
                filteredTickets = filteredTickets.filter(t => selectedCauldrons.includes(t.cauldron_id));
            }
            
            // Apply courier filter (if any selected)
            if (selectedCouriers.length > 0) {
                filteredTickets = filteredTickets.filter(t => selectedCouriers.includes(t.courier_id));
            }
            
            if (filterDate) {
                filteredTickets = filteredTickets.filter(t => t.date === filterDate);
            }
            
            // Apply status filter
            if (selectedStatuses.length > 0 && selectedStatuses.length < 2) {
                // Only filter if not all statuses are selected
                if (selectedStatuses.includes('suspicious')) {
                    filteredTickets = filteredTickets.filter(t => isTicketSuspicious(t));
                } else if (selectedStatuses.includes('normal')) {
                    filteredTickets = filteredTickets.filter(t => !isTicketSuspicious(t));
                }
            }
            
            // Apply sorting
            switch(sortBy) {
                case 'date-desc':
                    filteredTickets.sort((a, b) => b.date.localeCompare(a.date));
                    break;
                case 'date-asc':
                    filteredTickets.sort((a, b) => a.date.localeCompare(b.date));
                    break;
                case 'amount-desc':
                    filteredTickets.sort((a, b) => b.amount_collected - a.amount_collected);
                    break;
                case 'amount-asc':
                    filteredTickets.sort((a, b) => a.amount_collected - b.amount_collected);
                    break;
            }
            
            // Reset to first page
            currentTicketPage = 1;
            displayTickets();
        }
        
        // Reset all filters
        function resetFilters() {
            document.getElementById('sort-by').value = 'date-desc';
            document.getElementById('filter-date').value = '';
            
            // Check all cauldron checkboxes
            document.querySelectorAll('#filter-cauldron-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            // Check all courier checkboxes
            document.querySelectorAll('#filter-courier-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            // Check all status checkboxes
            document.querySelectorAll('#filter-status-container input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
            
            updateDropdownLabels();
            applyFiltersAndSort();
        }
        
        // Update statistics panel
        function updateStatistics() {
            const statusCounts = {
                match: 0,
                'over-reported': 0,
                'under-reported': 0,
                'no-drain-match': 0,
                'no-data': 0
            };
            
            // Track suspicious tickets by courier and missing amounts by cauldron
            const suspiciousByCourier = {}; // courier_id -> count
            const suspiciousByCauldron = {}; // cauldron_id -> count
            
            // Count tickets by status
            filteredTickets.forEach(ticket => {
                const status = ticket.discrepancy_status || 'no-data';
                if (statusCounts.hasOwnProperty(status)) {
                    statusCounts[status]++;
                }
                
                // Track suspicious tickets by courier (witch)
                if (status === 'over-reported' || status === 'under-reported' || status === 'no-drain-match') {
                    const courier = ticket.courier_id || 'Unknown';
                    suspiciousByCourier[courier] = (suspiciousByCourier[courier] || 0) + 1;
                    
                    // Track suspicious tickets by cauldron
                    const cauldron = ticket.cauldron_id || 'Unknown';
                    suspiciousByCauldron[cauldron] = (suspiciousByCauldron[cauldron] || 0) + 1;
                }
            });
            
            const total = filteredTickets.length;
            const suspicious = statusCounts['over-reported'] + statusCounts['under-reported'] + statusCounts['no-drain-match'];
            const validMatches = statusCounts.match;
            
            // Find courier with most suspicious tickets
            let topCourier = 'None';
            let topCourierCount = 0;
            Object.entries(suspiciousByCourier).forEach(([courier, count]) => {
                if (count > topCourierCount) {
                    topCourierCount = count;
                    topCourier = courier;
                }
            });
            
            // Find cauldron with most suspicious tickets
            let topCauldron = 'None';
            let topCauldronCount = 0;
            Object.entries(suspiciousByCauldron).forEach(([cauldron, count]) => {
                if (count > topCauldronCount) {
                    topCauldronCount = count;
                    topCauldron = cauldron;
                }
            });
            
            // Determine color for suspicious rate
            let suspiciousColor = '#66ff66'; // green
            if (suspicious > total * 0.2) suspiciousColor = '#cc0000'; // darker red
            else if (suspicious > total * 0.1) suspiciousColor = '#ffaa66'; // orange
            else if (suspicious > total * 0.05) suspiciousColor = '#ffff66'; // yellow
            
            // Build stats HTML
            const statsHTML = `
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">‚úÖ Match Tickets</div>
                    <div class="ticket-stat-value" style="color: #66ff66;">${validMatches}/${total}</div>
                </div>
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">‚ö†Ô∏è Suspicious Tickets</div>
                    <div class="ticket-stat-value" style="color: ${suspiciousColor};">${suspicious}/${total}</div>
                    <div class="ticket-stat-sub">Over: ${statusCounts['over-reported']} | Under: ${statusCounts['under-reported']} | No-Drain: ${statusCounts['no-drain-match']}</div>
                </div>
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">üßô Top Fraudulent Witch</div>
                    <div class="ticket-stat-value" style="font-size: 20px;">${topCourier}</div>
                    <div class="ticket-stat-sub">${topCourierCount} suspicious ticket${topCourierCount !== 1 ? 's' : ''}</div>
                </div>
                <div class="ticket-stat-card">
                    <div class="ticket-stat-label">ü™Ñ Most Problematic Cauldron</div>
                    <div class="ticket-stat-value" style="font-size: 20px;">${topCauldron}</div>
                    <div class="ticket-stat-sub">${topCauldronCount} suspicious ticket${topCauldronCount !== 1 ? 's' : ''}</div>
                </div>
            `;
            
            document.getElementById('ticket-stats').innerHTML = statsHTML;
        }
        
        // Display tickets for current page
        function displayTickets() {
            const tbody = document.getElementById('ticket-tbody');
            tbody.innerHTML = '';
            
            const totalPages = Math.ceil(filteredTickets.length / ticketsPerPage);
            const startIndex = (currentTicketPage - 1) * ticketsPerPage;
            const endIndex = Math.min(startIndex + ticketsPerPage, filteredTickets.length);
            
            const ticketsToShow = filteredTickets.slice(startIndex, endIndex);
            
            // Update statistics
            updateStatistics();
            
            ticketsToShow.forEach(ticket => {
                const row = document.createElement('tr');
                const isSuspicious = isTicketSuspicious(ticket);
                
                if (isSuspicious) {
                    row.classList.add('suspicious');
                }
                // Status text per spec flags
                let statusText = 'Unknown';
                if (ticket.discrepancy_status === 'match') statusText = '‚úÖ Match';
                else if (ticket.discrepancy_status === 'over-reported') statusText = 'üö® Over-Reported';
                else if (ticket.discrepancy_status === 'under-reported') statusText = 'üü° Under-Reported';
                else if (ticket.discrepancy_status === 'no-drain-match') statusText = '‚ö†Ô∏è No Drain Match';
                else if (ticket.discrepancy_status === 'no-data') statusText = '‚ùì No Historical Data';

                row.innerHTML = `
                    <td>${ticket.ticket_id || 'N/A'}</td>
                    <td>${ticket.cauldron_id || 'N/A'}</td>
                    <td>${ticket.amount_collected ? ticket.amount_collected.toFixed(2) : 'N/A'}</td>
                    <td>${ticket.courier_id || 'N/A'}</td>
                    <td>${ticket.date || 'N/A'}</td>
                    <td>${isSuspicious ? '<span class=\"suspicious-badge\">SUSPICIOUS</span>' : statusText}</td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Update pagination
            document.getElementById('ticket-page-info').textContent = `Page ${currentTicketPage} of ${totalPages}`;
            document.getElementById('ticket-prev').disabled = currentTicketPage === 1;
            document.getElementById('ticket-next').disabled = currentTicketPage === totalPages;
        }
        
        // Change ticket page
        function changeTicketPage(delta) {
            const totalPages = Math.ceil(allTickets.length / ticketsPerPage);
            currentTicketPage = Math.max(1, Math.min(totalPages, currentTicketPage + delta));
            displayTickets();
        }
        
        // Main initialization
        async function init() {
            initMap();
            
            const cauldronsLoaded = await loadCauldrons();
            const marketLoaded = await loadMarket();
            const networkLoaded = await loadNetwork();
            const timestampsLoaded = await loadTimestamps();
            const ticketsLoaded = await loadTickets();
            
            if (cauldronsLoaded && timestampsLoaded) {
                document.getElementById('loading').style.display = 'none';
                centerMap();
                setupTimelineControls();
                
                // Load the latest data if available
                if (cachedData && cachedData.length > 0) {
                    await loadLevelsAtIndex(cachedData.length - 1);
                }

                // After both data and tickets are ready, compute discrepancies and refresh view
                computeDailyDrainEvents();
                reAnnotateDrainStatusUsingRates();
                annotateTicketDiscrepancies();
                applyFiltersAndSort();
            }
        }
        
        // ========================================
        // CAULDRON TRENDS TAB FUNCTIONS
        // ========================================
        
        let trendChart = null;
        let trendsSelectedCauldrons = new Set();
        
        // Initialize trends tab
        function initTrendsTab() {
            if (!cachedData || cachedData.length === 0) {
                document.getElementById('trends-loading').textContent = 'No trend data available';
                return;
            }
            
            // Populate year/month/day dropdowns (same as main timeline)
            populateTrendsDateSelectors();
            
            // Populate cauldron filter checkboxes
            populateTrendsCauldronFilter();
            
            // Set default: select all cauldrons
            trendsSelectedCauldrons = new Set(cauldrons.map(c => c.id));
            
            // Set default date to most recent data
            if (allTimestamps.length > 0) {
                const latestDate = new Date(allTimestamps[allTimestamps.length - 1]);
                document.getElementById('trends-year').value = latestDate.getFullYear();
                populateTrendsMonths();
                document.getElementById('trends-month').value = latestDate.getMonth() + 1;
                populateTrendsDays();
                document.getElementById('trends-day').value = latestDate.getDate();
            }
            
            document.getElementById('trends-loading').style.display = 'none';
            document.getElementById('trends-container').style.display = 'block';
            
            // Initialize the chart
            updateTrendsGraph();
        }
        
        function populateTrendsDateSelectors() {
            const years = new Set();
            allTimestamps.forEach(ts => {
                const date = new Date(ts);
                years.add(date.getFullYear());
            });
            
            const yearSelect = document.getElementById('trends-year');
            yearSelect.innerHTML = '';
            Array.from(years).sort().forEach(year => {
                const opt = document.createElement('option');
                opt.value = year;
                opt.textContent = year;
                yearSelect.appendChild(opt);
            });
            
            yearSelect.onchange = () => {
                populateTrendsMonths();
                updateTrendsGraph();
            };
        }
        
        function populateTrendsMonths() {
            const year = parseInt(document.getElementById('trends-year').value);
            if (!year) return;
            
            const months = new Set();
            allTimestamps.forEach(ts => {
                const date = new Date(ts);
                if (date.getFullYear() === year) {
                    months.add(date.getMonth() + 1);
                }
            });
            
            const monthSelect = document.getElementById('trends-month');
            monthSelect.innerHTML = '';
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];
            
            Array.from(months).sort((a, b) => a - b).forEach(month => {
                const opt = document.createElement('option');
                opt.value = month;
                opt.textContent = monthNames[month - 1];
                monthSelect.appendChild(opt);
            });
            
            monthSelect.onchange = () => {
                populateTrendsDays();
                updateTrendsGraph();
            };
        }
        
        function populateTrendsDays() {
            const year = parseInt(document.getElementById('trends-year').value);
            const month = parseInt(document.getElementById('trends-month').value);
            if (!year || !month) return;
            
            const days = new Set();
            allTimestamps.forEach(ts => {
                const date = new Date(ts);
                if (date.getFullYear() === year && date.getMonth() + 1 === month) {
                    days.add(date.getDate());
                }
            });
            
            const daySelect = document.getElementById('trends-day');
            daySelect.innerHTML = '';
            
            Array.from(days).sort((a, b) => a - b).forEach(day => {
                const opt = document.createElement('option');
                opt.value = day;
                opt.textContent = day;
                daySelect.appendChild(opt);
            });
        }
        
        function populateTrendsCauldronFilter() {
            const container = document.getElementById('trends-cauldron-container');
            container.innerHTML = '';
            
            cauldrons.forEach(cauldron => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `trends-cauldron-${cauldron.id}`;
                checkbox.value = cauldron.id;
                checkbox.checked = true;
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        trendsSelectedCauldrons.add(cauldron.id);
                    } else {
                        trendsSelectedCauldrons.delete(cauldron.id);
                    }
                    updateTrendsCauldronLabel();
                    updateTrendsGraph();
                };
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = cauldron.id; // Just the ID, no "Cauldron" prefix
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
            
            updateTrendsCauldronLabel();
        }
        
        function updateTrendsCauldronLabel() {
            const label = document.getElementById('trends-cauldron-label');
            const total = cauldrons.length;
            const selected = trendsSelectedCauldrons.size;
            
            if (selected === 0) {
                label.textContent = 'None Selected';
            } else if (selected === total) {
                label.textContent = 'All Cauldrons';
            } else {
                label.textContent = `${selected} Selected`;
            }
        }
        
        function resetTrendsFilters() {
            // Reset to all cauldrons
            trendsSelectedCauldrons = new Set(cauldrons.map(c => c.id));
            cauldrons.forEach(cauldron => {
                document.getElementById(`trends-cauldron-${cauldron.id}`).checked = true;
            });
            updateTrendsCauldronLabel();
            
            // Reset to latest date
            if (allTimestamps.length > 0) {
                const latestDate = new Date(allTimestamps[allTimestamps.length - 1]);
                document.getElementById('trends-year').value = latestDate.getFullYear();
                populateTrendsMonths();
                document.getElementById('trends-month').value = latestDate.getMonth() + 1;
                populateTrendsDays();
                document.getElementById('trends-day').value = latestDate.getDate();
            }
            
            updateTrendsGraph();
        }
        
        function updateTrendsGraph() {
            const year = parseInt(document.getElementById('trends-year').value);
            const month = parseInt(document.getElementById('trends-month').value);
            const day = parseInt(document.getElementById('trends-day').value);
            const timezone = document.getElementById('trends-timezone').value;
            
            if (!year || !month || !day) return;
            
                // Create date range for the selected day in the selected timezone
                // We need to capture all UTC data that falls within this local day
                const localStartOfDay = new Date(year, month - 1, day, 0, 0, 0);
                const localEndOfDay = new Date(year, month - 1, day, 23, 59, 59);
            
                // We need to look at a wider UTC range to catch all data
                // For example, if viewing Nov 1 in PT (UTC-7), we need data from Nov 1 07:00 UTC to Nov 2 07:00 UTC
                const utcStart = new Date(Date.UTC(year, month - 1, day) - 24 * 60 * 60 * 1000); // 1 day before
                const utcEnd = new Date(Date.UTC(year, month - 1, day + 1) + 24 * 60 * 60 * 1000); // 1 day after
            
                const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            
                // Filter data with expanded UTC range, then filter by actual local time
                const dayData = cachedData.filter(record => {
                    const utcDate = new Date(record.timestamp);
                    if (utcDate < utcStart || utcDate > utcEnd) return false;
                
                    // Convert to local timezone and check if it falls on the selected day
                    const localDate = new Date(utcDate.toLocaleString('en-US', { timeZone: timezone }));
                    return localDate.getFullYear() === year &&
                           localDate.getMonth() === month - 1 &&
                           localDate.getDate() === day;
                });
            
            if (dayData.length === 0) {
                    console.log('No data for selected date:', dateStr, 'in timezone:', timezone);
                return;
            }
            
                console.log(`Found ${dayData.length} records for ${dateStr} in ${timezone}`);
            
            // Prepare datasets for selected cauldrons
            const datasets = [];
            const colors = [
                '#667eea', '#764ba2', '#f093fb', '#4facfe',
                '#43e97b', '#fa709a', '#fee140', '#30cfd0'
            ];
            
            let colorIndex = 0;
            cauldrons.forEach(cauldron => {
                if (!trendsSelectedCauldrons.has(cauldron.id)) return;
                
                const data = dayData.map(record => {
                    // Convert UTC timestamp to selected timezone
                    const utcDate = new Date(record.timestamp);
                    const localTime = new Date(utcDate.toLocaleString('en-US', { timeZone: timezone }));
                    
                    return {
                        x: localTime,
                        y: record.cauldron_levels?.[cauldron.id] || 0
                    };
                });
                
                datasets.push({
                    label: cauldron.id, // Just the ID, no "Cauldron" prefix
                    data: data,
                    borderColor: colors[colorIndex % colors.length],
                    backgroundColor: colors[colorIndex % colors.length] + '20',
                    borderWidth: 2,
                    tension: 0.1,
                    pointRadius: 1,
                    pointHoverRadius: 5
                });
                
                colorIndex++;
            });
            
            // Destroy previous chart if exists
            if (trendChart) {
                trendChart.destroy();
            }
            
            // Get timezone abbreviation for display
            const tzAbbr = timezone === 'UTC' ? 'UTC' : 
                          timezone.includes('New_York') ? 'ET' :
                          timezone.includes('Chicago') ? 'CT' :
                          timezone.includes('Denver') ? 'MT' :
                          timezone.includes('Los_Angeles') ? 'PT' :
                          timezone.includes('Phoenix') ? 'MST' :
                          timezone.includes('Anchorage') ? 'AKT' :
                          timezone.includes('Honolulu') ? 'HST' :
                          timezone.includes('London') ? 'GMT' :
                          timezone.includes('Paris') ? 'CET' :
                          timezone.includes('Tokyo') ? 'JST' :
                          timezone.includes('Shanghai') ? 'CST' :
                          timezone.includes('Sydney') ? 'AEDT' : timezone;
            
            // Create new chart
            const ctx = document.getElementById('trend-chart').getContext('2d');
            trendChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Cauldron Levels - ${dateStr} (${tzAbbr})`,
                            font: {
                                size: 18,
                                family: 'Cinzel, serif',
                                weight: '700'
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' L';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                                min: localStartOfDay,
                                max: localEndOfDay,
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: `Time of Day (${tzAbbr})`,
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 25
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Potion Level (L)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // ========================================
        // ANALYTICS DASHBOARD FUNCTIONS
        // ========================================
        
        let analyticsInitialized = false;
        let courierChart = null;
        let cauldronChart = null;
        
        async function initAnalyticsTab() {
            if (analyticsInitialized) {
                console.log('Analytics already initialized');
                return;
            }
            
            console.log('Initializing Analytics Dashboard...');
            document.getElementById('analytics-loading').style.display = 'block';
            document.getElementById('analytics-container').style.display = 'none';
            
            try {
                // Wait for tickets to be loaded
                if (allTickets.length === 0) {
                    await loadTickets();
                }
                
                // Calculate analytics
                calculateAnalytics();
                
                document.getElementById('analytics-loading').style.display = 'none';
                document.getElementById('analytics-container').style.display = 'block';
                analyticsInitialized = true;
            } catch (error) {
                console.error('Error initializing analytics:', error);
                document.getElementById('analytics-loading').textContent = 'Error loading analytics: ' + error.message;
            }
        }
        
        function calculateAnalytics() {
            // Overview Statistics
            const totalTickets = allTickets.length;
            const suspiciousTickets = allTickets.filter(t => {
                // Count tickets that are suspicious or high-risk
                return t.confidence_level === 'suspicious' || 
                       t.confidence_level === 'high-risk' ||
                       t.discrepancy_status === 'over-reported' || 
                       t.discrepancy_status === 'under-reported' ||
                       t.discrepancy_status === 'no-drain-match';
            }).length;
            const totalVolume = allTickets.reduce((sum, t) => sum + (t.amount_collected || 0), 0);
            const avgPerDelivery = totalTickets > 0 ? totalVolume / totalTickets : 0;
            const suspiciousRate = totalTickets > 0 ? (suspiciousTickets / totalTickets * 100) : 0;
            
            // Unique couriers and cauldrons
            const uniqueCouriers = new Set(allTickets.map(t => t.courier_id)).size;
            const uniqueCauldrons = new Set(allTickets.map(t => t.cauldron_id)).size;
            
            document.getElementById('analytics-overview').innerHTML = `
                <div class="stat-card">
                    <h3>${totalTickets.toLocaleString()}</h3>
                    <p>Total Deliveries</p>
                </div>
                <div class="stat-card">
                    <h3>${totalVolume.toFixed(0).toLocaleString()}L</h3>
                    <p>Total Volume Collected</p>
                </div>
                <div class="stat-card">
                    <h3>${avgPerDelivery.toFixed(1)}L</h3>
                    <p>Avg per Delivery</p>
                </div>
                <div class="stat-card" style="background: ${suspiciousRate > 10 ? '#d9681a' : '#764ba2'}">
                    <h3>${suspiciousRate.toFixed(1)}%</h3>
                    <p>Suspicious Rate</p>
                </div>
                <div class="stat-card">
                    <h3>${uniqueCouriers}</h3>
                    <p>Active Couriers</p>
                </div>
                <div class="stat-card">
                    <h3>${uniqueCauldrons}</h3>
                    <p>Active Cauldrons</p>
                </div>
            `;
            
            // Courier Performance Analysis
            analyzeCourierPerformance();
            
            // Cauldron Efficiency Analysis
            analyzeCauldronEfficiency();
            
            // Network Efficiency
            analyzeNetworkEfficiency(uniqueCauldrons);
        }
        
        function analyzeCourierPerformance() {
            const courierStats = {};
            
            allTickets.forEach(ticket => {
                const courier = ticket.courier_id;
                if (!courier) return;
                
                if (!courierStats[courier]) {
                    courierStats[courier] = {
                        deliveries: 0,
                        totalCollected: 0,
                        suspicious: 0
                    };
                }
                
                courierStats[courier].deliveries++;
                courierStats[courier].totalCollected += ticket.amount_collected || 0;
                
                if (ticket.confidence_level === 'suspicious' || 
                    ticket.confidence_level === 'high-risk' ||
                    ticket.discrepancy_status === 'over-reported' || 
                    ticket.discrepancy_status === 'under-reported' ||
                    ticket.discrepancy_status === 'no-drain-match') {
                    courierStats[courier].suspicious++;
                }
            });
            
            // Convert to array and calculate metrics
            const courierData = Object.entries(courierStats).map(([courier, stats]) => {
                const avgPerDelivery = stats.deliveries > 0 ? stats.totalCollected / stats.deliveries : 0;
                const suspiciousRate = stats.deliveries > 0 ? (stats.suspicious / stats.deliveries * 100) : 0;
                const performanceRating = calculatePerformanceRating(stats.deliveries, avgPerDelivery, suspiciousRate);
                
                return {
                    courier,
                    deliveries: stats.deliveries,
                    totalCollected: stats.totalCollected,
                    avgPerDelivery,
                    suspiciousRate,
                    performanceRating
                };
            }).sort((a, b) => b.performanceRating - a.performanceRating); // Sort by performance rating
            
            // Populate table
            const tbody = document.getElementById('courier-tbody');
            tbody.innerHTML = courierData.map(data => {
                const ratingColor = data.performanceRating >= 80 ? '#28a745' : 
                                   data.performanceRating >= 60 ? '#ffc107' : '#dc3545';
                return `
                    <tr>
                        <td><strong>${data.courier}</strong></td>
                        <td>${data.deliveries}</td>
                        <td>${data.totalCollected.toFixed(1)}L</td>
                        <td>${data.avgPerDelivery.toFixed(1)}L</td>
                        <td>${data.suspiciousRate.toFixed(1)}%</td>
                        <td style="color: ${ratingColor}; font-weight: bold;">${data.performanceRating.toFixed(0)}/100</td>
                    </tr>
                `;
            }).join('');
            
            // Create chart
            const topCouriers = courierData.slice(0, 5);
            const ctx = document.getElementById('courier-performance-chart').getContext('2d');
            
            if (courierChart) courierChart.destroy();
            
            courierChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topCouriers.map(d => d.courier),
                    datasets: [{
                        label: 'Performance Rating',
                        data: topCouriers.map(d => d.performanceRating),
                        backgroundColor: '#667eea',
                        borderColor: '#4c51bf',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top 5 Couriers by Performance Rating',
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Performance Rating' }
                        }
                    }
                }
            });
        }
        
        function calculatePerformanceRating(deliveries, avgPerDelivery, suspiciousRate) {
            // Rating based on: deliveries (40%), avg amount (30%), low suspicious rate (30%)
            const deliveryScore = Math.min(deliveries / 50, 1) * 40;
            const avgScore = Math.min(avgPerDelivery / 100, 1) * 30;
            const reliabilityScore = Math.max(0, (1 - suspiciousRate / 100)) * 30;
            
            return deliveryScore + avgScore + reliabilityScore;
        }
        
        function analyzeCauldronEfficiency() {
            const cauldronStats = {};
            
            allTickets.forEach(ticket => {
                const cauldron = ticket.cauldron_id;
                if (!cauldron) return;
                
                if (!cauldronStats[cauldron]) {
                    cauldronStats[cauldron] = {
                        collections: 0,
                        totalOutput: 0,
                        timestamps: []
                    };
                }
                
                cauldronStats[cauldron].collections++;
                cauldronStats[cauldron].totalOutput += ticket.amount_collected || 0;
                
                if (ticket.timestamp) {
                    const timestamp = new Date(ticket.timestamp);
                    if (!isNaN(timestamp.getTime())) {
                        cauldronStats[cauldron].timestamps.push(timestamp);
                    }
                }
            });
            
            // Calculate metrics
            const cauldronData = Object.entries(cauldronStats).map(([cauldronId, stats]) => {
                const cauldronInfo = cauldrons.find(c => c.id === cauldronId);
                const maxVolume = cauldronInfo?.max_volume || 1000;
                
                let daysDiff = 1;
                if (stats.timestamps.length > 1) {
                    const timestamps = stats.timestamps.sort((a, b) => a - b);
                    const firstDate = timestamps[0];
                    const lastDate = timestamps[timestamps.length - 1];
                    daysDiff = Math.max(1, (lastDate - firstDate) / (1000 * 60 * 60 * 24));
                }
                
                const avgFillRate = stats.totalOutput / daysDiff;
                
                // Status based on fill rate
                const status = avgFillRate > 80 ? 'Excellent' : avgFillRate > 50 ? 'Good' : 'Low';
                
                return {
                    cauldron: cauldronId,
                    collections: stats.collections,
                    totalOutput: stats.totalOutput,
                    avgFillRate,
                    status
                };
            }).sort((a, b) => b.totalOutput - a.totalOutput);
            
            // Populate table
            const tbody = document.getElementById('cauldron-efficiency-tbody');
            tbody.innerHTML = cauldronData.map(data => {
                const statusColor = data.status === 'Excellent' ? '#28a745' : 
                                   data.status === 'Good' ? '#ffc107' : '#dc3545';
                return `
                    <tr>
                        <td><strong>${data.cauldron}</strong></td>
                        <td>${data.collections}</td>
                        <td>${data.totalOutput.toFixed(1)}L</td>
                        <td>${data.avgFillRate.toFixed(1)}L</td>
                        <td style="color: ${statusColor}; font-weight: bold;">${data.status}</td>
                    </tr>
                `;
            }).join('');
            
            // Create chart
            const topCauldrons = cauldronData.slice(0, 10);
            const ctx = document.getElementById('cauldron-efficiency-chart').getContext('2d');
            
            if (cauldronChart) cauldronChart.destroy();
            
            cauldronChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topCauldrons.map(d => d.cauldron),
                    datasets: [{
                        label: 'Total Output (L)',
                        data: topCauldrons.map(d => d.totalOutput),
                        backgroundColor: '#764ba2',
                        borderColor: '#5a3880',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Top 10 Cauldrons by Total Output',
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Volume (L)' }
                        }
                    }
                }
            });
        }
        
        function analyzeNetworkEfficiency(uniqueCauldrons) {
            const routeStats = {};
            
            allTickets.forEach(ticket => {
                if (!ticket.cauldron_id) return;
                
                const route = `${ticket.cauldron_id} ‚Üí Market`;
                if (!routeStats[route]) {
                    routeStats[route] = {
                        trips: 0,
                        totalVolume: 0
                    };
                }
                routeStats[route].trips++;
                routeStats[route].totalVolume += ticket.amount_collected || 0;
            });
            
            const totalRoutes = Object.keys(routeStats).length;
            const totalTrips = Object.values(routeStats).reduce((sum, s) => sum + s.trips, 0);
            const avgTripsPerRoute = totalRoutes > 0 ? totalTrips / totalRoutes : 0;
            const busiestRoute = Object.entries(routeStats).sort((a, b) => b[1].trips - a[1].trips)[0];
            
            const networkCoverage = cauldrons.length > 0 ? (uniqueCauldrons / cauldrons.length * 100) : 0;
            
            document.getElementById('network-stats').innerHTML = `
                <div class="stat-card">
                    <h3>${totalRoutes}</h3>
                    <p>Active Routes</p>
                </div>
                <div class="stat-card">
                    <h3>${totalTrips.toLocaleString()}</h3>
                    <p>Total Trips</p>
                </div>
                <div class="stat-card">
                    <h3>${avgTripsPerRoute.toFixed(1)}</h3>
                    <p>Avg Trips per Route</p>
                </div>
                <div class="stat-card">
                    <h3>${busiestRoute ? busiestRoute[0].split(' ‚Üí ')[0] : 'N/A'}</h3>
                    <p>Busiest Route (${busiestRoute ? busiestRoute[1].trips : 0} trips)</p>
                </div>
                <div class="stat-card">
                    <h3>${networkCoverage.toFixed(0)}%</h3>
                    <p>Network Coverage</p>
                </div>
            `;
        }
        
        // ========================================
        // ROUTE OPTIMIZATION TAB FUNCTIONS
        // ========================================
        
        let optimizationInitialized = false;
        let optimizationMap = null;
        let routePolylines = [];
        
        async function initOptimizationTab() {
            if (optimizationInitialized) {
                console.log('Optimization already initialized');
                return;
            }
            
            console.log('Initializing Route Optimization Tab...');
            
            // No old loading elements to hide - new tab is ready to go
            optimizationInitialized = true;
        }
        
        // Main optimization function - calculate daily pickup schedule
        function optimizeDailySchedule() {
            console.log('üîÑ Starting daily pickup schedule optimization...');
            
            try {
                // Step 1: Analyze each cauldron's fill dynamics
                const cauldronAnalysis = analyzeCauldronFillRates();
                
                if (!cauldronAnalysis || cauldronAnalysis.length === 0) {
                    console.error('No cauldron analysis data available');
                    alert('Error: No cauldron data available for optimization');
                    return;
                }
                
                // Step 2: Create frequency-based collection schedules for each cauldron
                const collectionSchedule = createFrequencyBasedSchedule(cauldronAnalysis);
                
                if (!collectionSchedule || collectionSchedule.tasks.length === 0) {
                    console.error('No collection tasks created');
                    alert('Error: Could not create collection schedule');
                    return;
                }
                
                // Step 3: Optimize tasks into efficient routes
                const routes = bundleTasksIntoRoutes(collectionSchedule, cauldronAnalysis);
                
                if (!routes || routes.length === 0) {
                    console.error('No routes created');
                    alert('Error: Could not create routes');
                    return;
                }
                
                // Step 4: Calculate minimum witches needed to execute all routes
                console.log('About to calculate minimum witches...');
                console.log('Routes before calculation:', routes);
                console.log('Cauldron analysis before calculation:', cauldronAnalysis);
                
                let witchCount;
                try {
                    witchCount = calculateMinimumWitchesForSchedule(routes, cauldronAnalysis);
                } catch (error) {
                    console.error('‚ùå Error in calculateMinimumWitchesForSchedule:', error);
                    witchCount = NaN;
                }
                
                console.log('Witch count result:', witchCount, 'isNaN:', isNaN(witchCount));
                
                if (isNaN(witchCount) || witchCount < 1) {
                    console.error('Invalid witch count:', witchCount);
                    console.error('Routes:', routes);
                    console.error('Cauldron Analysis:', cauldronAnalysis);
                    alert('Error: Could not calculate witch count. Check console for details.');
                    return;
                }
                
                // Step 5: Validate that all cauldrons are visited frequently enough
                const validation = validateCollectionFrequency(routes, cauldronAnalysis);
                if (!validation.valid) {
                    console.warn('‚ö†Ô∏è Collection frequency validation failed:', validation.issues);
                }
                
                // Step 6: Display results
                displayOptimizationResults(routes, witchCount, cauldronAnalysis, validation);
                
                console.log(`‚úÖ Optimization complete: ${witchCount} witches needed`);
            } catch (error) {
                console.error('Error during optimization:', error);
                alert('Optimization failed: ' + error.message);
            }
        }
        
        // Helper: Calculate distance between two points using Haversine formula
        function getDistance(pos1, pos2) {
            if (!pos1 || !pos2) return 0;
            return calculateDistance(pos1.lat, pos1.lng, pos2.lat, pos2.lng);
        }
        
        // Analyze fill rates and calculate time to overflow for each cauldron
        function analyzeCauldronFillRates() {
            const analysis = [];
            
            console.log('üìä Analyzing cauldron fill dynamics...');
            
            cauldrons.forEach(cauldron => {
                const id = cauldron.id;
                const maxVolume = cauldron.max_volume || 1000;
                const currentLevel = currentLevels[id] || 0;
                
                // Fill rate (L/min ‚Üí L/hr)
                const fillRate = (cauldronFillRates[id] || 0.5) * 60; // L/hr
                
                // Drain rate represents collection efficiency (how fast witches can drain during pickup)
                // This is NOT continuous - it only happens during collection
                // For overflow prediction, we only care about FILL rate
                const drainRate = (cauldronDrainRates[id] || 0) * 60; // L/hr (for reference only)
                
                // Net accumulation rate = fill rate (cauldrons continuously fill, only drain when collected)
                const netRate = fillRate; // Cauldrons accumulate at fill rate between collections
                
                // Time until full (hours) - based on fill rate only
                let timeToFull = Infinity;
                let status = 'Normal';
                
                if (netRate > 0) {
                    const remainingCapacity = maxVolume - currentLevel;
                    timeToFull = remainingCapacity / netRate;
                    
                    if (timeToFull < 24) {
                        status = 'Critical';
                    } else if (timeToFull < 72) {
                        status = 'Urgent';
                    } else {
                        status = 'Normal';
                    }
                } else {
                    status = 'Stable';
                }
                
                analysis.push({
                    id,
                    currentLevel,
                    maxVolume,
                    fillRate,
                    drainRate,
                    netRate,
                    timeToFull,
                    status,
                    location: {
                        lat: cauldron.latitude,
                        lng: cauldron.longitude
                    }
                });
                
                console.log(`  ${id}: Fill ${fillRate.toFixed(1)}L/h, Time to full: ${timeToFull === Infinity ? '‚àû' : timeToFull.toFixed(1) + 'h'}, Status: ${status}`);
            });
            
            return analysis;
        }
        
        // Create frequency-based collection schedule - each cauldron visited at its required frequency
        function createFrequencyBasedSchedule(cauldronAnalysis) {
            console.log('üìÖ Creating frequency-based collection schedule...');
            
            const schedule = {
                tasks: [],
                frequencyTiers: {
                    critical: [],  // < 6h to fill - need very frequent visits
                    urgent: [],    // 6-24h to fill
                    normal: []     // > 24h to fill
                }
            };
            
            cauldronAnalysis.forEach(cauldron => {
                const timeToFull = cauldron.timeToFull;
                
                // Calculate required visits per day for this cauldron
                // Visit frequency = slightly more often than needed (80% of time to full for safety)
                const safetyFactor = 0.8;
                const visitFrequency = timeToFull * safetyFactor; // hours between visits
                const visitsPerDay = Math.ceil(24 / visitFrequency);
                
                const tier = timeToFull < 6 ? 'critical' : timeToFull < 24 ? 'urgent' : 'normal';
                
                schedule.frequencyTiers[tier].push({
                    cauldron: cauldron,
                    visitFrequency: visitFrequency,
                    visitsPerDay: visitsPerDay
                });
                
                // Create individual collection tasks for each required visit
                for (let i = 0; i < visitsPerDay; i++) {
                    const visitTime = (i * visitFrequency); // When this visit should happen
                    schedule.tasks.push({
                        cauldronId: cauldron.id,
                        cauldron: cauldron,
                        visitTime: visitTime,
                        visitIndex: i,
                        tier: tier,
                        frequency: visitFrequency
                    });
                }
            });
            
            // Sort tasks by visit time
            schedule.tasks.sort((a, b) => a.visitTime - b.visitTime);
            
            console.log(`  Total collection tasks per day: ${schedule.tasks.length}`);
            console.log(`  Critical tier: ${schedule.frequencyTiers.critical.length} cauldrons`);
            console.log(`  Urgent tier: ${schedule.frequencyTiers.urgent.length} cauldrons`);
            console.log(`  Normal tier: ${schedule.frequencyTiers.normal.length} cauldrons`);
            
            return schedule;
        }
        
        // Bundle collection tasks into efficient routes based on timing and capacity
        function bundleTasksIntoRoutes(collectionSchedule, cauldronAnalysis) {
            console.log('üó∫Ô∏è Bundling tasks into efficient routes...');
            
            const WITCH_CAPACITY = calculateWitchCapacity();
            const marketLoc = market ? { lat: market.latitude, lng: market.longitude } : null;
            const marketId = market ? (market.id || 'market_001') : 'market_001';
            
            const routes = [];
            const tasks = [...collectionSchedule.tasks]; // Copy to avoid mutation
            
            // Redistribute normal-tier tasks (only 1 visit/day) more evenly throughout the day
            // This prevents all 10+ normal cauldrons from being visited at hour 0
            let normalTaskIndex = 0;
            const normalTasks = tasks.filter(t => t.tier === 'normal' && t.visitIndex === 0);
            if (normalTasks.length > 0) {
                const redistributionWindow = 20; // Spread over first 20 hours to leave buffer
                const spacing = redistributionWindow / normalTasks.length;
                normalTasks.forEach((task, idx) => {
                    task.visitTime = idx * spacing;
                    console.log(`  üìç Redistributed ${task.cauldronId} to hour ${task.visitTime.toFixed(1)}`);
                });
            }
            
            // Group tasks by time windows (1-hour windows)
            const timeWindows = {};
            tasks.forEach(task => {
                const window = Math.floor(task.visitTime);
                if (!timeWindows[window]) timeWindows[window] = [];
                timeWindows[window].push(task);
            });
            
            console.log(`  Time windows: ${Object.keys(timeWindows).length}`);
            
            // For each time window, create optimized routes
            Object.keys(timeWindows).sort((a, b) => Number(a) - Number(b)).forEach(windowStart => {
                const windowTasks = timeWindows[windowStart];
                console.log(`  Window ${windowStart}h: ${windowTasks.length} tasks`);
                
                // Group tasks in this window into capacity-constrained routes
                let currentRoute = null;
                
                windowTasks.forEach(task => {
                    const estimatedCycleTime = 3; // hours
                    const volumePerCycle = task.cauldron.fillRate * estimatedCycleTime;
                    
                    // Check if we need a new route
                    if (!currentRoute || 
                        (currentRoute.totalVolume + volumePerCycle > WITCH_CAPACITY) ||
                        currentRoute.cauldrons.length >= 8) {
                        
                        // Finalize previous route
                        if (currentRoute && currentRoute.cauldrons.length > 0) {
                            finalizeRoute(currentRoute, marketLoc, marketId);
                            routes.push(currentRoute);
                        }
                        
                        // Start new route
                        currentRoute = {
                            windowStart: Number(windowStart),
                            cauldrons: [],
                            tasks: [],
                            sequence: [],
                            distance: 0,
                            time: 0,
                            totalVolume: 0
                        };
                    }
                    
                    // Add task to current route
                    currentRoute.tasks.push(task);
                    if (!currentRoute.cauldrons.find(c => c.id === task.cauldronId)) {
                        currentRoute.cauldrons.push(task.cauldron);
                        currentRoute.totalVolume += volumePerCycle;
                    }
                });
                
                // Finalize last route in window
                if (currentRoute && currentRoute.cauldrons.length > 0) {
                    finalizeRoute(currentRoute, marketLoc, marketId);
                    
                    // Check if route extends past 24h and adjust if needed
                    const routeDurationHours = currentRoute.time / 60;
                    const routeEndTime = currentRoute.windowStart + routeDurationHours;
                    
                    if (routeEndTime > 24) {
                        const adjustedStart = 24 - routeDurationHours;
                        if (adjustedStart >= 0) {
                            console.log(`    ‚è∞ Adjusted route start from ${currentRoute.windowStart}h to ${adjustedStart.toFixed(1)}h to fit within 24h`);
                            currentRoute.windowStart = adjustedStart;
                        } else {
                            console.warn(`    ‚ö†Ô∏è Route too long (${routeDurationHours.toFixed(1)}h) to fit in 24h window - needs splitting`);
                        }
                    }
                    
                    routes.push(currentRoute);
                }
            });
            
            console.log(`  Created ${routes.length} routes`);
            routes.forEach((route, idx) => {
                const endTime = route.windowStart + (route.time / 60);
                console.log(`  Route ${idx + 1} (window ${route.windowStart.toFixed(1)}h-${endTime.toFixed(1)}h): ${route.cauldrons.length} cauldrons, ${route.time.toFixed(0)}min, ${route.totalVolume.toFixed(1)}L`);
            });
            
            return routes;
        }
        
        // Finalize a route by calculating optimal TSP sequence and travel times
        function finalizeRoute(route, marketLoc, marketId) {
            // Create TSP sequence for cauldrons in this route
            const unvisited = new Set(route.cauldrons.map(c => c.id));
            let currentPos = marketLoc;
            let currentId = marketId;
            
            route.sequence = ['market'];
            route.distance = 0;
            route.time = 0;
            
            // Greedy TSP
            while (unvisited.size > 0) {
                let nearest = null;
                let minTime = Infinity;
                let nearestDist = 0;
                
                unvisited.forEach(cId => {
                    const c = route.cauldrons.find(ca => ca.id === cId);
                    const travelTime = calculateTravelTime(currentPos, c.location, currentId, cId);
                    if (travelTime < minTime) {
                        minTime = travelTime;
                        nearest = cId;
                        nearestDist = getDistance(currentPos, c.location);
                    }
                });
                
                if (nearest) {
                    const cauldronData = route.cauldrons.find(c => c.id === nearest);
                    route.sequence.push(nearest);
                    route.time += minTime + 5; // 5 min collection
                    route.distance += nearestDist;
                    currentPos = cauldronData.location;
                    currentId = nearest;
                    unvisited.delete(nearest);
                }
            }
            
            // Return to market
            const returnTime = calculateTravelTime(currentPos, marketLoc, currentId, marketId);
            const returnDist = getDistance(currentPos, marketLoc);
            route.time += returnTime + 15; // 15 min dropoff
            route.distance += returnDist;
            route.sequence.push('market');
        }
        
        // Validate that all cauldrons are visited frequently enough
        function validateCollectionFrequency(routes, cauldronAnalysis) {
            console.log('‚úÖ Validating collection frequency...');
            
            const validation = {
                valid: true,
                issues: []
            };
            
            // Count how many times each cauldron is visited per day
            const visitCounts = {};
            routes.forEach(route => {
                route.cauldrons.forEach(cauldron => {
                    visitCounts[cauldron.id] = (visitCounts[cauldron.id] || 0) + 1;
                });
            });
            
            // Check each cauldron
            cauldronAnalysis.forEach(cauldron => {
                const visitsPerDay = visitCounts[cauldron.id] || 0;
                const requiredVisitsPerDay = Math.ceil(24 / (cauldron.timeToFull * 0.8)); // 80% safety margin
                
                if (visitsPerDay < requiredVisitsPerDay) {
                    validation.valid = false;
                    validation.issues.push({
                        cauldronId: cauldron.id,
                        actualVisits: visitsPerDay,
                        requiredVisits: requiredVisitsPerDay,
                        timeToFull: cauldron.timeToFull,
                        severity: cauldron.status
                    });
                    console.warn(`  ‚ö†Ô∏è ${cauldron.id}: ${visitsPerDay} visits/day (need ${requiredVisitsPerDay})`);
                } else {
                    console.log(`  ‚úì ${cauldron.id}: ${visitsPerDay} visits/day (need ${requiredVisitsPerDay})`);
                }
            });
            
            return validation;
        }
        
        // Calculate minimum witch carrying capacity from historical ticket data
        function calculateWitchCapacity() {
            if (!allTickets || allTickets.length === 0) {
                console.log('  No ticket data available, using default capacity: 200L');
                return 200;
            }
            
            // Find max amount collected in a single ticket
            const maxCollected = Math.max(...allTickets.map(t => t.amount_collected || 0));
            
            // Also calculate per-courier max to see if they differ
            const courierMaxCapacities = {};
            allTickets.forEach(ticket => {
                const courier = ticket.courier_id;
                const amount = ticket.amount_collected || 0;
                if (!courierMaxCapacities[courier] || amount > courierMaxCapacities[courier]) {
                    courierMaxCapacities[courier] = amount;
                }
            });
            
            console.log('  üìä Courier capacity analysis from historical data:');
            Object.entries(courierMaxCapacities).forEach(([courier, max]) => {
                console.log(`    ${courier}: max ${max.toFixed(1)}L collected in single trip`);
            });
            
            const capacities = Object.values(courierMaxCapacities);
            const minCapacity = Math.min(...capacities);
            const maxCapacity = Math.max(...capacities);
            const avgCapacity = capacities.reduce((a, b) => a + b, 0) / capacities.length;
            
            console.log(`  Overall capacity range: ${minCapacity.toFixed(1)}L - ${maxCapacity.toFixed(1)}L`);
            console.log(`  Average max collected: ${avgCapacity.toFixed(1)}L`);
            
            // Use the maximum observed as the capacity (assume witches fill to max)
            const capacity = maxCollected;
            console.log(`  ‚úÖ Using witch capacity: ${capacity.toFixed(1)}L (max observed from data)`);
            
            return capacity;
        }
        
        // Create optimal routes using TSP (Traveling Salesman Problem) greedy approach
        function createOptimalTSPRoutes(cauldronAnalysis) {
            console.log('üó∫Ô∏è Creating optimal routes using TSP...');
            console.log(`  Network has ${network ? network.length : 0} edges`);
            
            // Debug: Show what edges exist in network
            if (network && network.length > 0) {
                console.log('  Network edges (first 10):');
                network.slice(0, 10).forEach(e => {
                    console.log(`    ${e.from_node} ‚Üî ${e.to_node}: ${e.travel_time_minutes || e.travel_time} min`);
                });
                if (network.length > 10) console.log(`    ... and ${network.length - 10} more edges`);
                
                // Check which nodes are in the network
                const nodes = new Set();
                network.forEach(e => {
                    nodes.add(e.from_node);
                    nodes.add(e.to_node);
                });
                console.log(`  Network contains ${nodes.size} unique nodes:`, Array.from(nodes).sort());
            }
            
            const routes = [];
            const unvisited = new Set(cauldronAnalysis.map(c => c.id));
            const MAX_CAULDRONS_PER_ROUTE = 8;
            
            const marketLoc = market ? { lat: market.latitude, lng: market.longitude } : null;
            // Market ID in network might be 'market_001', 'MARKET', or 'market'
            const marketId = market ? (market.id || 'market_001') : 'market_001';
            console.log(`  Using market ID: ${marketId}`);
            
            // Calculate witch capacity from historical data
            const WITCH_CAPACITY = calculateWitchCapacity();
            
            while (unvisited.size > 0) {
                const route = {
                    cauldrons: [],
                    sequence: [],
                    distance: 0,
                    time: 0,
                    totalVolume: 0  // Track total liquid collected
                };
                
                let currentPos = marketLoc;
                let currentId = marketId;  // Use marketId instead of 'market'
                
                // Greedy TSP: always pick nearest unvisited cauldron based on TRAVEL TIME
                // Also respect witch carrying capacity
                while (unvisited.size > 0 && route.cauldrons.length < MAX_CAULDRONS_PER_ROUTE) {
                    let nearest = null;
                    let minTime = Infinity;
                    let nearestDist = 0;
                    
                    unvisited.forEach(cId => {
                        const c = cauldronAnalysis.find(ca => ca.id === cId);
                        
                        // Check if adding this cauldron would exceed witch capacity
                        // We need to consider how much will accumulate in one collection cycle
                        // Since we don't know cycle time yet, use a conservative estimate based on most urgent cauldron
                        // Most urgent fills in 3h, so use 3h as cycle time for capacity planning
                        const estimatedCycleTime = 3; // hours (conservative - based on most urgent cauldron)
                        const volumePerCycle = c.fillRate * estimatedCycleTime; // L accumulated per cycle
                        
                        if (route.totalVolume + volumePerCycle > WITCH_CAPACITY) {
                            return; // Skip this cauldron - would exceed capacity
                        }
                        
                        // Use actual network travel time, not straight-line distance
                        const travelTime = calculateTravelTime(currentPos, c.location, currentId, cId);
                        if (travelTime < minTime) {
                            minTime = travelTime;
                            nearest = cId;
                            nearestDist = getDistance(currentPos, c.location);
                        }
                    });
                    
                    if (nearest) {
                        const cauldronData = cauldronAnalysis.find(c => c.id === nearest);
                        route.sequence.push(nearest);
                        route.cauldrons.push(cauldronData);
                        
                        // Track volume collected per cycle (not current snapshot level)
                        const estimatedCycleTime = 3; // hours
                        const volumePerCycle = cauldronData.fillRate * estimatedCycleTime;
                        route.totalVolume += volumePerCycle;
                        
                        // Add travel time and collection time
                        route.time += minTime + 5; // 5 min collection time
                        route.distance += nearestDist;
                        
                        currentPos = cauldronData.location;
                        currentId = nearest;
                        unvisited.delete(nearest);
                    } else {
                        // No more cauldrons can be added without exceeding capacity
                        break;
                    }
                }
                
                // Return to market
                if (route.cauldrons.length > 0) {
                    const returnDist = getDistance(currentPos, marketLoc);
                    const returnTime = calculateTravelTime(currentPos, marketLoc, currentId, marketId);  // Use marketId
                    route.distance += returnDist;
                    route.time += returnTime + 15; // 15 min dropoff time
                    
                    routes.push(route);
                    console.log(`  Route ${routes.length}: ${route.cauldrons.length} cauldrons, ${route.distance.toFixed(2)}km, ${route.time.toFixed(1)}min, ${route.totalVolume.toFixed(1)}L collected (capacity: ${WITCH_CAPACITY}L)`);
                }
            }
            
            return routes;
        }
        
        // Calculate minimum witches needed based on most urgent cauldron
        // Calculate minimum witches for frequency-based schedule
        function calculateMinimumWitchesForSchedule(routes, cauldronAnalysis) {
            console.log('üßô Calculating minimum witches for frequency-based schedule...');
            console.log(`  Total routes to execute per day: ${routes.length}`);
            
            // Calculate total workload (all route times per day)
            let totalWorkMinutes = 0;
            routes.forEach((route, idx) => {
                console.log(`  Route ${idx + 1} (window ${route.windowStart}h): ${route.time.toFixed(0)} min`);
                totalWorkMinutes += route.time;
            });
            
            const totalWorkHours = totalWorkMinutes / 60;
            const availableHoursPerWitch = 24; // Each witch works 24 hours (shift system)
            
            // Start with minimum estimate, but we'll increase if needed during assignment
            let witchesNeeded = Math.ceil(totalWorkHours / availableHoursPerWitch);
            
            console.log(`  Total work per day: ${totalWorkHours.toFixed(2)} hours`);
            console.log(`  Available per witch: ${availableHoursPerWitch} hours/day`);
            console.log(`  Initial estimate: ${witchesNeeded} witches`);
            
            // Helper function to check if two time ranges overlap
            function timeRangesOverlap(start1, end1, start2, end2) {
                return (start1 < end2 && end1 > start2);
            }
            
            // Create witch schedules - start with initial estimate
            const witchSchedules = [];
            for (let i = 0; i < witchesNeeded; i++) {
                witchSchedules.push({
                    witchId: `Witch-${i + 1}`,
                    assignments: [],
                    shiftStart: 0,
                    totalTime: 0
                });
            }
            
            // Distribute routes across witches, ensuring they fit within 24h
            // A witch can't be in two places at once, so check for ANY time overlap for same witch
            let currentWitchIndex = 0;
            
            routes.forEach((route, idx) => {
                const routeDurationHours = route.time / 60;
                const routeStartTime = route.windowStart;
                const routeEndTime = route.windowStart + routeDurationHours;
                
                // Check if route extends past 24h - if so, we can't use it
                if (routeEndTime > 24) {
                    console.warn(`  ‚ö†Ô∏è Route ${idx + 1} extends past 24h (${routeStartTime.toFixed(1)}h-${routeEndTime.toFixed(1)}h) - skipping`);
                    return;
                }
                
                // Find a witch that has capacity for this route
                let assigned = false;
                let attempts = 0;
                const maxAttempts = witchSchedules.length * 2; // Try all witches twice
                
                while (!assigned && attempts < maxAttempts) {
                    const witch = witchSchedules[currentWitchIndex];
                    
                    // Check if adding this route would exceed 24 hours total work
                    if (witch.totalTime + routeDurationHours <= 24) {
                        // Check if this witch already has an assignment during this time
                        // A witch can't be in two places at once!
                        const hasTimeConflict = witch.assignments.some(assignment => {
                            return timeRangesOverlap(
                                routeStartTime, routeEndTime,
                                assignment.startHour, assignment.endHour
                            );
                        });
                        
                        if (!hasTimeConflict) {
                            witch.assignments.push({
                                routeNum: idx + 1,
                                route: route,
                                startHour: routeStartTime,
                                endHour: routeEndTime,
                                cauldrons: route.cauldrons.map(c => c.id)
                            });
                            witch.totalTime += routeDurationHours;
                            assigned = true;
                            console.log(`    ‚úì Assigned Route ${idx + 1} (${routeStartTime.toFixed(1)}h-${routeEndTime.toFixed(1)}h) to ${witch.witchId}`);
                        }
                    }
                    
                    if (!assigned) {
                        currentWitchIndex = (currentWitchIndex + 1) % witchSchedules.length;
                        attempts++;
                    }
                }
                
                // If still not assigned after trying all witches, add a new witch
                if (!assigned) {
                    witchesNeeded++;
                    const newWitch = {
                        witchId: `Witch-${witchesNeeded}`,
                        assignments: [{
                            routeNum: idx + 1,
                            route: route,
                            startHour: routeStartTime,
                            endHour: routeEndTime,
                            cauldrons: route.cauldrons.map(c => c.id)
                        }],
                        shiftStart: 0,
                        totalTime: routeDurationHours
                    };
                    witchSchedules.push(newWitch);
                    console.log(`    ‚ûï Added ${newWitch.witchId} for Route ${idx + 1} (${routeStartTime.toFixed(1)}h-${routeEndTime.toFixed(1)}h)`);
                }
            });
            
            // Sort each witch's assignments by start time for clean daily pattern
            witchSchedules.forEach(witch => {
                witch.assignments.sort((a, b) => a.startHour - b.startHour);
                console.log(`  ${witch.witchId}: ${witch.assignments.length} routes, ${witch.totalTime.toFixed(2)}h total`);
            });
            
            console.log(`\n  üìä Final allocation: ${witchesNeeded} witches needed (started with ${Math.ceil(totalWorkHours / availableHoursPerWitch)})`);
            
            // Store for display
            window.currentWitchSchedules = witchSchedules;
            
            // Store routes
            routes.forEach((route, idx) => {
                const assignedWitch = witchSchedules.find(w => 
                    w.assignments.some(a => a.routeNum === idx + 1)
                );
                route.witchId = assignedWitch ? assignedWitch.witchId : 'Unassigned';
                route.dailyFrequency = 1; // Each route executed once per window
                route.cycleTime = 24;
            });
            
            return witchesNeeded;
        }
        
        // OLD FUNCTION - kept for backwards compatibility
        function calculateMinimumWitchesForDailySchedule(routes, cauldronAnalysis) {
            console.log('üßô Calculating minimum witches for sustainable daily operation...');
            console.log('  Routes count:', routes ? routes.length : 'null');
            console.log('  Cauldron count:', cauldronAnalysis ? cauldronAnalysis.length : 'null');
            
            // Validate inputs
            if (!routes || routes.length === 0) {
                console.error('No routes provided');
                return 1;
            }
            
            if (!cauldronAnalysis || cauldronAnalysis.length === 0) {
                console.error('No cauldron analysis provided');
                return 1;
            }
            
            // Find the most urgent cauldron (shortest time to full)
            let minTimeToFull = Infinity;
            console.log('  Analyzing cauldron fill rates:');
            cauldronAnalysis.forEach(c => {
                const ttf = c.timeToFull;
                console.log(`    ${c.id}: timeToFull = ${ttf.toFixed(1)}h, Status: ${c.status}`);
                if (ttf < minTimeToFull && ttf > 0 && isFinite(ttf)) {
                    minTimeToFull = ttf;
                }
            });
            
            // For sustainable operation, each route must be completed before ANY cauldron overflows
            // Required frequency = how often we must complete ALL routes (in hours)
            const requiredFrequency = minTimeToFull; // hours
            console.log(`  Most urgent cauldron fills in ${minTimeToFull.toFixed(1)} hours`);
            console.log(`  All routes must be completed every ${requiredFrequency.toFixed(1)} hours to prevent overflow`);
            
            // Calculate total route time (time for 1 witch to do all routes sequentially)
            let totalRouteTime = 0;
            routes.forEach((r, idx) => {
                const routeTime = r.time || 0;
                console.log(`    Route ${idx + 1}: ${routeTime.toFixed(1)} minutes`);
                totalRouteTime += routeTime;
            });
            totalRouteTime = totalRouteTime / 60; // Convert to hours
            console.log(`  Total sequential route time: ${totalRouteTime.toFixed(2)} hours`);
            
            // Validate totalRouteTime
            if (!totalRouteTime || totalRouteTime <= 0 || isNaN(totalRouteTime)) {
                console.error('‚ùå Invalid total route time:', totalRouteTime);
                return 1;
            }
            
            // For daily sustainable operation:
            // Witches needed = ceil(total route time / required frequency)
            // This ensures routes can be completed in parallel fast enough
            const witchesNeeded = Math.max(1, Math.ceil(totalRouteTime / requiredFrequency));
            
            console.log(`  Calculation: ceil(${totalRouteTime.toFixed(2)} / ${requiredFrequency.toFixed(1)})`);
            console.log(`  Witches needed for sustainable 24/7 operation: ${witchesNeeded}`);
            
            // Validate result
            if (isNaN(witchesNeeded) || !isFinite(witchesNeeded)) {
                console.error('Invalid witches calculation result');
                return 1;
            }
            
            // Calculate how many times per day each route must be completed
            const completionsPerDay = 24 / requiredFrequency;
            console.log(`  Each route must be completed ${completionsPerDay.toFixed(1)} times per day`);
            
            // Create a fixed daily schedule where each witch has the same routine every day
            // Each witch gets assigned specific routes that repeat at fixed times
            const witchSchedules = [];
            
            // Calculate shift start times - evenly distribute witches across the day
            const shiftOffset = 24 / witchesNeeded; // Hours between witch start times
            
            for (let witchNum = 1; witchNum <= witchesNeeded; witchNum++) {
                const witchStartOffset = (witchNum - 1) * shiftOffset;
                
                witchSchedules.push({
                    witchId: `Witch-${witchNum}`,
                    assignments: [],
                    shiftStart: witchStartOffset
                });
            }
            
            // Assign each witch to handle all routes, but starting at their offset time
            witchSchedules.forEach(witch => {
                let currentTime = witch.shiftStart;
                let cyclesCompleted = 0;
                
                // Each witch completes full cycles (both routes) starting from their shift time
                while (currentTime < 24 && cyclesCompleted < completionsPerDay / witchesNeeded) {
                    routes.forEach(route => {
                        const durationHours = route.time / 60;
                        const endTime = currentTime + durationHours;
                        
                        // Only add if route completes before end of day
                        if (endTime <= 24) {
                            witch.assignments.push({
                                routeNum: routes.indexOf(route) + 1,
                                route: route,
                                startHour: currentTime,
                                endHour: endTime,
                                cauldrons: route.cauldrons.map(c => c.id)
                            });
                            currentTime = endTime;
                        }
                    });
                    
                    cyclesCompleted++;
                    
                    // Wait for next cycle time (aligned to 3-hour intervals)
                    const nextCycleStart = witch.shiftStart + (cyclesCompleted * requiredFrequency);
                    currentTime = Math.max(currentTime, nextCycleStart);
                }
            });
            
            // Store witch schedules for display
            routes.forEach((route, idx) => {
                route.witchId = `Witch-${(idx % witchesNeeded) + 1}`;
                route.dailyFrequency = Math.ceil(completionsPerDay);
                route.cycleTime = requiredFrequency;
            });
            
            // Store for results display
            window.currentWitchSchedules = witchSchedules;
            
            return witchesNeeded;
        }
        
        // Display optimization results
        function displayOptimizationResults(routes, witchCount, cauldronAnalysis, validation) {
            // Show results container
            document.getElementById('optimization-results').style.display = 'block';
            
            // Display validation results first
            let validationHTML = '';
            if (validation && !validation.valid) {
                validationHTML = `
                    <div style="background: #fff3cd; padding: 15px; margin-bottom: 20px; border-left: 4px solid #ffc107; border-radius: 4px;">
                        <h4 style="color: #856404; margin: 0 0 10px 0;">‚ö†Ô∏è Collection Frequency Validation Issues</h4>
                        <p style="margin: 0 0 10px 0;">Some cauldrons are not being visited frequently enough:</p>
                        <ul style="margin: 0; padding-left: 20px;">
                            ${validation.issues.map(issue => `
                                <li><strong>${issue.cauldronId}</strong>: ${issue.actualVisits} visits/day (needs ${issue.requiredVisits}) - 
                                fills in ${issue.timeToFull.toFixed(1)}h [${issue.severity}]</li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            } else if (validation) {
                validationHTML = `
                    <div style="background: #d4edda; padding: 15px; margin-bottom: 20px; border-left: 4px solid #28a745; border-radius: 4px;">
                        <h4 style="color: #155724; margin: 0;">‚úÖ All Cauldrons Visited Frequently Enough</h4>
                        <p style="margin: 5px 0 0 0;">Every cauldron is scheduled for collection before it can overflow.</p>
                    </div>
                `;
            }
            
            if (validationHTML) {
                const statsContainer = document.getElementById('optimization-stats');
                statsContainer.insertAdjacentHTML('beforebegin', validationHTML);
            }
            
            // Stats
            const totalDistance = routes.reduce((sum, r) => sum + r.distance, 0);
            const totalTime = routes.reduce((sum, r) => sum + r.time, 0);
            const mostUrgentCauldron = cauldronAnalysis.reduce((min, c) => 
                c.timeToFull < min.timeToFull ? c : min
            );
            const avgTimeToFull = cauldronAnalysis.reduce((sum, c) => sum + (c.timeToFull === Infinity ? 0 : c.timeToFull), 0) / 
                                  cauldronAnalysis.filter(c => c.timeToFull !== Infinity).length;
            const cycleFrequency = routes[0]?.dailyFrequency || 1;
            
            document.getElementById('optimization-stats').innerHTML = `
                <div class="stat-item">
                    <div class="stat-label">Minimum Witches Required (24/7 Operation)</div>
                    <div class="stat-value">${witchCount} üßô</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Routes Per Day</div>
                    <div class="stat-value">${routes.length}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Distance Per Day</div>
                    <div class="stat-value">${totalDistance.toFixed(2)} km</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Work Time Per Day</div>
                    <div class="stat-value">${(totalTime / 60).toFixed(2)} hours</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Work Per Witch</div>
                    <div class="stat-value">${(totalTime / 60 / witchCount).toFixed(2)} hours/day</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Most Urgent Cauldron</div>
                    <div class="stat-value">${mostUrgentCauldron.id} (${mostUrgentCauldron.timeToFull.toFixed(1)}h)</div>
                </div>
            `;
            
            // Schedule table - show all witch schedules
            let scheduleHTML = '';
            
            if (window.currentWitchSchedules && window.currentWitchSchedules.length > 0) {
                // Show detailed witch schedules
                window.currentWitchSchedules.forEach(witch => {
                    witch.assignments.forEach((assignment, idx) => {
                        const timeRange = `${assignment.startHour.toFixed(1)}h - ${assignment.endHour.toFixed(1)}h`;
                        const sequence = ['market', ...assignment.cauldrons, 'market'].join(' ‚Üí ');
                        
                        scheduleHTML += `
                            <tr>
                                <td>${witch.witchId}</td>
                                <td>${sequence}</td>
                                <td>${assignment.cauldrons.length}</td>
                                <td>${assignment.route.distance.toFixed(2)}</td>
                                <td>${assignment.route.time.toFixed(0)}</td>
                                <td>${timeRange}</td>
                            </tr>
                        `;
                    });
                });
            } else {
                // Fallback to original route display
                routes.forEach(route => {
                    scheduleHTML += `
                        <tr>
                            <td>${route.witchId}</td>
                            <td>${route.sequence.join(' ‚Üí ')}</td>
                            <td>${route.cauldrons.length}</td>
                            <td>${route.distance.toFixed(2)}</td>
                            <td>${route.time.toFixed(0)}</td>
                            <td>${route.dailyFrequency}x per day</td>
                        </tr>
                    `;
                });
            }
            document.getElementById('schedule-tbody').innerHTML = scheduleHTML;
            
            // Cauldron analysis table
            let analysisHTML = '';
            cauldronAnalysis.forEach(c => {
                const statusColor = c.status === 'Critical' ? '#ff4444' : 
                                   c.status === 'Urgent' ? '#ffaa00' : '#44aa44';
                analysisHTML += `
                    <tr>
                        <td>${c.id}</td>
                        <td>${c.currentLevel.toFixed(0)}</td>
                        <td>${c.maxVolume}</td>
                        <td>${c.fillRate.toFixed(2)}</td>
                        <td>${c.drainRate.toFixed(2)}</td>
                        <td style="font-weight: bold; color: #ff8800">${c.netRate.toFixed(2)}</td>
                        <td>${c.timeToFull === Infinity ? '‚àû' : c.timeToFull.toFixed(1) + 'h'}</td>
                        <td style="color: ${statusColor}; font-weight: bold;">${c.status}</td>
                    </tr>
                `;
            });
            document.getElementById('cauldron-analysis-tbody').innerHTML = analysisHTML;
            
            // Analyze concurrent cauldron visits
            analyzeConcurrentVisits(window.currentWitchSchedules, cauldronAnalysis);
            
            // Draw route map
            displayRouteMap(routes);
        }
        
        // Analyze which cauldrons are visited by multiple witches
        function analyzeConcurrentVisits(witchSchedules, cauldronAnalysis) {
            if (!witchSchedules) return;
            
            // Track all visits to each cauldron with precise timing
            const cauldronVisits = {};
            
            witchSchedules.forEach(witch => {
                witch.assignments.forEach(assignment => {
                    const routeStartTime = assignment.startHour;
                    let currentTime = routeStartTime;
                    
                    // Calculate when each cauldron in the route is visited
                    assignment.cauldrons.forEach((cauldronId, idx) => {
                        if (!cauldronVisits[cauldronId]) {
                            cauldronVisits[cauldronId] = [];
                        }
                        
                        // Estimate time at this cauldron (travel time accumulated + collection time)
                        // This is approximate - we assume even distribution of time across cauldrons
                        const cauldronCount = assignment.cauldrons.length;
                        const totalRouteTime = assignment.endHour - assignment.startHour;
                        const timePerCauldron = totalRouteTime / cauldronCount;
                        const visitStart = routeStartTime + (idx * timePerCauldron);
                        const visitEnd = visitStart + (5/60); // 5 minutes collection time converted to hours
                        
                        cauldronVisits[cauldronId].push({
                            witch: witch.witchId,
                            routeStartHour: assignment.startHour,
                            routeEndHour: assignment.endHour,
                            visitStartHour: visitStart,
                            visitEndHour: visitEnd
                        });
                    });
                });
            });
            
            // Find concurrent visits (overlapping time windows AT THE SAME CAULDRON)
            let concurrentHTML = '<h4 style="color: #667eea; margin-bottom: 10px;">üîç Concurrent Cauldron Access Analysis</h4>';
            concurrentHTML += '<p style="color: #666; font-size: 14px; margin-bottom: 15px;">Checking if multiple witches visit the same cauldron at the exact same time (not just overlapping routes).</p>';
            let hasConcurrent = false;
            let totalOverlaps = 0;
            const conflictDetails = [];
            
            Object.keys(cauldronVisits).forEach(cauldronId => {
                const visits = cauldronVisits[cauldronId];
                
                if (visits.length > 1) {
                    // Check for overlapping VISIT times (not route times) at this specific cauldron
                    const overlaps = [];
                    for (let i = 0; i < visits.length; i++) {
                        for (let j = i + 1; j < visits.length; j++) {
                            const v1 = visits[i];
                            const v2 = visits[j];
                            
                            // Check if actual visit times at THIS cauldron overlap
                            // Two visits overlap if one starts before the other ends
                            if (v1.visitStartHour < v2.visitEndHour && v2.visitStartHour < v1.visitEndHour) {
                                overlaps.push({ v1, v2 });
                                totalOverlaps++;
                                conflictDetails.push({
                                    cauldron: cauldronId,
                                    witch1: v1.witch,
                                    witch2: v2.witch,
                                    visit1: `${v1.visitStartHour.toFixed(2)}h-${v1.visitEndHour.toFixed(2)}h`,
                                    visit2: `${v2.visitStartHour.toFixed(2)}h-${v2.visitEndHour.toFixed(2)}h`,
                                    route1: `(route: ${v1.routeStartHour.toFixed(1)}h-${v1.routeEndHour.toFixed(1)}h)`,
                                    route2: `(route: ${v2.routeStartHour.toFixed(1)}h-${v2.routeEndHour.toFixed(1)}h)`
                                });
                            }
                        }
                    }
                    
                    if (overlaps.length > 0) {
                        hasConcurrent = true;
                        concurrentHTML += `<div style="background: #fff3cd; padding: 10px; margin: 10px 0; border-left: 4px solid #ffaa00; border-radius: 4px;">`;
                        concurrentHTML += `<strong style="color: #ff8800;">‚ö†Ô∏è ${cauldronId}</strong>: `;
                        overlaps.forEach(overlap => {
                            concurrentHTML += `${overlap.v1.witch} visits at ${overlap.v1.visitStartHour.toFixed(2)}h <strong>CONFLICTS</strong> with ${overlap.v2.witch} at ${overlap.v2.visitStartHour.toFixed(2)}h. `;
                        });
                        concurrentHTML += `</div>`;
                    }
                }
            });
            
            if (!hasConcurrent) {
                concurrentHTML += `<div style="background: #d4edda; padding: 15px; margin: 10px 0; border-left: 4px solid #28a745; border-radius: 4px; color: #155724;">`;
                concurrentHTML += `‚úÖ <strong>No concurrent access detected!</strong> While witch routes may overlap in time, each witch visits different cauldrons at different moments. `;
                concurrentHTML += `All ${witchSchedules.length} witches can operate simultaneously without conflicts.`;
                concurrentHTML += `<br><br><em>Cauldrons do NOT need multiple drain taps - only one witch accesses each cauldron at any given time.</em>`;
                concurrentHTML += `</div>`;
            } else {
                concurrentHTML += `<div style="background: #f8d7da; padding: 15px; margin: 10px 0; border-left: 4px solid #dc3545; border-radius: 4px; color: #721c24;">`;
                concurrentHTML += `‚ö†Ô∏è <strong>CONCURRENT ACCESS DETECTED: ${totalOverlaps} conflict(s) found!</strong><br><br>`;
                concurrentHTML += `Multiple witches will attempt to drain from the same cauldron at the exact same time. Solutions:<br>`;
                concurrentHTML += `<strong>Option 1:</strong> Add small time offsets between witch shifts to stagger cauldron visits<br>`;
                concurrentHTML += `<strong>Option 2:</strong> Cauldrons support multiple drain taps for parallel draining<br>`;
                concurrentHTML += `<strong>Option 3:</strong> Witches coordinate/queue when conflict detected (adds wait time)`;
                concurrentHTML += `</div>`;
                
                // Detailed conflict report
                concurrentHTML += `<div style="background: #fff; padding: 10px; margin: 10px 0; border: 1px solid #dc3545; border-radius: 4px;">`;
                concurrentHTML += `<strong>Detailed Conflict Report:</strong><br>`;
                conflictDetails.forEach((conf, idx) => {
                    concurrentHTML += `${idx + 1}. <strong>${conf.cauldron}</strong>: ${conf.witch1} visits ${conf.visit1} ‚ö° ${conf.witch2} visits ${conf.visit2}<br>`;
                    concurrentHTML += `   &nbsp;&nbsp;&nbsp;${conf.route1} vs ${conf.route2}<br>`;
                });
                concurrentHTML += `</div>`;
            }
            
            // Add visit schedule for each cauldron
            concurrentHTML += `<h4 style="color: #667eea; margin: 20px 0 10px 0;">üìÖ Cauldron Visit Schedule (Precise Timing)</h4>`;
            Object.keys(cauldronVisits).sort().forEach(cauldronId => {
                const visits = cauldronVisits[cauldronId];
                const cauldron = cauldronAnalysis.find(c => c.id === cauldronId);
                const timeToFull = cauldron ? cauldron.timeToFull.toFixed(1) : 'N/A';
                
                // Check if this cauldron has any conflicts
                const hasConflict = visits.length > 1 && visits.some((v1, i) => 
                    visits.slice(i + 1).some(v2 => 
                        v1.visitStartHour < v2.visitEndHour && v2.visitStartHour < v1.visitEndHour
                    )
                );
                
                const borderColor = hasConflict ? '#dc3545' : '#28a745';
                const bgColor = hasConflict ? 'rgba(248, 215, 218, 0.3)' : 'rgba(255,255,255,0.8)';
                
                concurrentHTML += `<div style="background: ${bgColor}; padding: 8px; margin: 5px 0; border-radius: 4px; border: 1px solid ${borderColor};">`;
                concurrentHTML += `<strong>${cauldronId}</strong> (fills in ${timeToFull}h) - visited ${visits.length}x per day: `;
                concurrentHTML += visits.map(v => `${v.witch} at ${v.visitStartHour.toFixed(2)}h (¬±${(5/60).toFixed(2)}h)`).join(', ');
                if (hasConflict) {
                    concurrentHTML += ` <span style="color: #dc3545; font-weight: bold;">‚ö†Ô∏è CONFLICT</span>`;
                }
                concurrentHTML += `</div>`;
            });
            
            // Insert before the cauldron analysis table
            const cauldronAnalysisDiv = document.querySelector('#cauldron-analysis-tbody').parentElement.parentElement;
            const analysisSection = document.createElement('div');
            analysisSection.style.cssText = 'background: rgba(255,255,255,0.5); padding: 20px; border-radius: 10px; margin-bottom: 20px;';
            analysisSection.innerHTML = concurrentHTML;
            cauldronAnalysisDiv.parentElement.insertBefore(analysisSection, cauldronAnalysisDiv);
        }
        
        // Display routes on map
        function displayRouteMap(routes) {
            // Clear existing map if any
            const mapContainer = document.getElementById('route-map');
            mapContainer.innerHTML = '';
            
            const routeMap = L.map('route-map').setView([cauldrons[0].latitude, cauldrons[0].longitude], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(routeMap);
            
            // Add market marker
            if (market) {
                L.marker([market.latitude, market.longitude], {
                    icon: L.icon({
                        iconUrl: '/static/images/markers/market.png',
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    })
                }).addTo(routeMap).bindPopup('<b>Market</b>');
            }
            
            // Colors for different routes
            const routeColors = ['#667eea', '#ff6b6b', '#4ecdc4', '#ffe66d', '#a8dadc', '#f1a2b7'];
            
            // Draw each route
            routes.forEach((route, idx) => {
                const color = routeColors[idx % routeColors.length];
                const marketLoc = market ? [market.latitude, market.longitude] : null;
                
                // Draw cauldron markers
                route.cauldrons.forEach(c => {
                    const cauldronObj = cauldrons.find(ca => ca.id === c.id);
                    L.circleMarker([c.location.lat, c.location.lng], {
                        radius: 8,
                        fillColor: color,
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(routeMap).bindPopup(`
                        <b>${c.id}</b><br>
                        Route: ${route.witchId}<br>
                        Net Rate: ${c.netRate.toFixed(2)} L/hr<br>
                        Time to Full: ${c.timeToFull === Infinity ? '‚àû' : c.timeToFull.toFixed(1) + 'h'}
                    `);
                });
                
                // Draw route path
                const routePath = [marketLoc];
                route.cauldrons.forEach(c => {
                    routePath.push([c.location.lat, c.location.lng]);
                });
                routePath.push(marketLoc); // Return to market
                
                L.polyline(routePath, {
                    color: color,
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                }).addTo(routeMap).bindPopup(`<b>${route.witchId}</b><br>${route.time.toFixed(0)} min cycle`);
            });
            
            setTimeout(() => routeMap.invalidateSize(), 100);
        }
        
        // OLD FUNCTION - keeping for compatibility
        function calculateOptimization() {
            console.log('Calculating optimal routes and schedules for continuous operation...');
            
            // Daily regime: 24-hour cycle, prevent all overflows (100% max volume target)
            const safetyMargin = 1.0; // 100% - prevent actual overflow
            const forecastHours = 24; // Daily regime
            
            console.log(`Settings: Daily regime (24 hours), preventing overflow at 100% capacity`);
            
            // Use simulation-based approach: create optimal routes, simulate, add witches as needed
            const result = calculateOptimalWitchesIteratively(forecastHours, safetyMargin);
            const routes = result.routes;
            const minWitches = result.totalWitches;
            const predictions = result.predictions;
            
            console.log(`Final: ${minWitches} witches required for daily operation`);
            
            // Display results
            displayOptimizationStats(minWitches, routes, predictions, forecastHours);
            displayWitchSchedule(routes);
            displayCauldronPredictions(predictions);
            visualizeRoutesOnMap(routes);
        }
        
        // Simulation-based approach: create optimal routes, simulate collection, add witches as needed
        function calculateOptimalWitchesIteratively(forecastHours, safetyMargin) {
            const WITCH_CAPACITY = 200; // Liters - max a witch can carry at once
            const MAX_ITERATIONS = 20; // Safety limit
            
            console.log('Starting iterative witch calculation...');
            
            // Get predictions to understand cauldron urgency
            const predictions = predictCauldronLevels(forecastHours, safetyMargin);
            
            let currentWitches = 1; // Start with 1 witch
            let routes = [];
            let overflowDetected = true;
            let iteration = 0;
            
            while (overflowDetected && iteration < MAX_ITERATIONS) {
                iteration++;
                
                // Create optimal routes for current number of witches
                routes = createOptimalRoutes(predictions, currentWitches);
                
                console.log(`\nIteration ${iteration}: Testing with ${currentWitches} witch(es)`);
                routes.forEach((r, i) => {
                    console.log(`  Route ${i + 1}: ${r.collections} cauldrons, ${r.time.toFixed(1)} min cycle, ${r.collectableVolume.toFixed(0)}L to collect`);
                });
                
                // Simulate collection over forecast period
                overflowDetected = simulateCollection(routes, forecastHours, safetyMargin, WITCH_CAPACITY);
                
                if (overflowDetected) {
                    console.log(`  ‚ùå Overflow detected - adding another witch`);
                    currentWitches++;
                } else {
                    console.log(`  ‚úÖ No overflow - ${currentWitches} witch(es) sufficient`);
                }
            }
            
            if (iteration >= MAX_ITERATIONS) {
                console.warn(`Warning: Reached max iterations (${MAX_ITERATIONS}). Using ${currentWitches} witches.`);
            }
            
            return {
                totalWitches: currentWitches,
                routes: routes,
                predictions: predictions
            };
        }
        
        // Create optimal routes distributed across N witches
        function createOptimalRoutes(predictions, numWitches) {
            // Sort cauldrons by urgency (most urgent first)
            const sortedCauldrons = [...predictions].sort((a, b) => 
                a.requiredCollectionFrequency - b.requiredCollectionFrequency
            );
            
            // Distribute cauldrons evenly across witches using round-robin
            const routes = Array(numWitches).fill(null).map(() => ({
                collections: 0,
                sequence: [],
                time: 0,
                distance: 0,
                collectableVolume: 0
            }));
            
            // Assign each cauldron to the witch with the shortest current route
            sortedCauldrons.forEach(cauldron => {
                // Find route with minimum time
                let minRoute = 0;
                let minTime = routes[0].time;
                for (let i = 1; i < routes.length; i++) {
                    if (routes[i].time < minTime) {
                        minTime = routes[i].time;
                        minRoute = i;
                    }
                }
                
                const route = routes[minRoute];
                const cauldronObj = cauldrons.find(c => c.id === cauldron.cauldron);
                const cauldronPos = { lat: cauldronObj.latitude, lng: cauldronObj.longitude };
                
                // Add to route sequence
                if (route.sequence.length === 0) {
                    // First cauldron - add travel from market
                    const travelTime = calculateTravelTime(marketPos, cauldronPos, 'market', cauldronObj.id);
                    route.time += travelTime + COLLECTION_TIME;
                    route.distance += getDistance(marketPos, cauldronPos);
                } else {
                    // Add travel from last cauldron
                    const lastCauldronId = route.sequence[route.sequence.length - 1];
                    const lastCauldron = cauldrons.find(c => c.id === lastCauldronId);
                    const lastPos = { lat: lastCauldron.latitude, lng: lastCauldron.longitude };
                    
                    const travelTime = calculateTravelTime(lastPos, cauldronPos, lastCauldronId, cauldronObj.id);
                    route.time += travelTime + COLLECTION_TIME;
                    route.distance += getDistance(lastPos, cauldronPos);
                }
                
                route.sequence.push(cauldron.cauldron);
                route.collections++;
                route.collectableVolume += cauldron.currentLevel; // Approximate collectable volume
            });
            
            // Add return to market for all routes
            routes.forEach(route => {
                if (route.sequence.length > 0) {
                    const lastCauldronId = route.sequence[route.sequence.length - 1];
                    const lastCauldron = cauldrons.find(c => c.id === lastCauldronId);
                    const lastPos = { lat: lastCauldron.latitude, lng: lastCauldron.longitude };
                    
                    const returnTime = calculateTravelTime(lastPos, marketPos, lastCauldronId, 'market');
                    route.time += returnTime + DROPOFF_TIME;
                    route.distance += getDistance(lastPos, marketPos);
                    
                    // Store cycle time in hours
                    route.cycleTime = route.time / 60;
                    route.witchesNeeded = 1; // Each route gets 1 witch in this approach
                }
            });
            
            return routes.filter(r => r.collections > 0);
        }
        
        // Simulate collection process over forecast period
        function simulateCollection(routes, forecastHours, safetyMargin, witchCapacity) {
            const timeStep = 0.1; // Simulate in 6-minute increments (0.1 hour)
            const numSteps = Math.floor(forecastHours / timeStep);
            
            // Initialize cauldron levels
            const cauldronLevels = {};
            cauldrons.forEach(cauldron => {
                cauldronLevels[cauldron.id] = currentLevels[cauldron.id] || 0;
            });
            
            // Track witch positions and next collection times
            const witchStates = routes.map((route, idx) => ({
                routeIndex: idx,
                nextCollectionTime: 0, // Start immediately
                currentCauldronIndex: 0,
                carrying: 0 // Amount currently carrying
            }));
            
            let overflowDetected = false;
            
            // Simulate over time
            for (let step = 0; step < numSteps && !overflowDetected; step++) {
                const currentTime = step * timeStep;
                
                // Check each witch
                witchStates.forEach(witch => {
                    const route = routes[witch.routeIndex];
                    
                    // Check if witch should collect now
                    if (currentTime >= witch.nextCollectionTime && route.sequence.length > 0) {
                        const cauldronId = route.sequence[witch.currentCauldronIndex];
                        const cauldron = cauldrons.find(c => c.id === cauldronId);
                        const maxVolume = cauldron.max_volume || 1000;
                        const currentLevel = cauldronLevels[cauldronId];
                        
                        // Collect up to witch capacity or current level
                        const amountToCollect = Math.min(currentLevel, witchCapacity);
                        cauldronLevels[cauldronId] -= amountToCollect;
                        witch.carrying += amountToCollect;
                        
                        // Move to next cauldron or return to market
                        witch.currentCauldronIndex++;
                        if (witch.currentCauldronIndex >= route.sequence.length) {
                            // Completed route - return to market and start over
                            witch.currentCauldronIndex = 0;
                            witch.carrying = 0; // Drop off at market
                            witch.nextCollectionTime = currentTime + route.cycleTime;
                        }
                    }
                });
                
                // Update cauldron levels (fill/drain)
                cauldrons.forEach(cauldron => {
                    const cauldronId = cauldron.id;
                    const maxVolume = cauldron.max_volume || 1000;
                    const safetyLevel = maxVolume * safetyMargin;
                    
                    const fillRate = (cauldronFillRates[cauldronId] || 0.5) * 60; // L/hr
                    const drainRate = (cauldronDrainRates[cauldronId] || fillRate * 2); // L/hr (drain faster than fill)
                    const netFillRate = fillRate - drainRate;
                    
                    // Update level
                    cauldronLevels[cauldronId] += netFillRate * timeStep;
                    
                    // Check for overflow beyond safety
                    if (cauldronLevels[cauldronId] > safetyLevel) {
                        console.log(`  Overflow at t=${currentTime.toFixed(1)}h: ${cauldronId} at ${cauldronLevels[cauldronId].toFixed(0)}L (safety: ${safetyLevel.toFixed(0)}L)`);
                        overflowDetected = true;
                    }
                    
                    // Cap at max volume
                    if (cauldronLevels[cauldronId] > maxVolume) {
                        cauldronLevels[cauldronId] = maxVolume;
                    }
                    
                    // Don't go below 0
                    if (cauldronLevels[cauldronId] < 0) {
                        cauldronLevels[cauldronId] = 0;
                    }
                });
            }
            
            return overflowDetected;
        }
        
        function predictCauldronLevels(forecastHours, safetyMargin) {
            const predictions = [];
            
            console.log(`Predicting for ${cauldrons.length} cauldrons with safety margin ${(safetyMargin * 100).toFixed(0)}%`);
            
            cauldrons.forEach(cauldron => {
                const cauldronId = cauldron.id;
                const maxVolume = cauldron.max_volume || 1000;
                
                // Use fill rate (L/min) - convert to L/hr
                const fillRate = cauldronFillRates[cauldronId] || 0.5; // L/min
                const fillRatePerHour = fillRate * 60; // L/hr
                
                // Use drain rate (L/min) if available - convert to L/hr
                const drainRate = cauldronDrainRates[cauldronId] || (fillRate * 2); // L/min
                const drainRatePerHour = drainRate * 60; // L/hr
                
                // Get current level
                const currentLevel = currentLevels[cauldronId] || 0;
                
                // Net fill rate (assuming continuous fill)
                const netFillRate = fillRatePerHour;
                
                // Calculate safety level
                const safetyLevel = maxVolume * safetyMargin;
                
                // Calculate REQUIRED collection frequency to stay below safety threshold AFTER forecast period
                // Predicted level after forecast period (without collection)
                const predictedLevel = currentLevel + (netFillRate * forecastHours);
                
                let requiredCollectionFrequency;
                if (predictedLevel <= safetyLevel) {
                    // Won't exceed safety threshold during forecast period - no urgent collection needed
                    requiredCollectionFrequency = forecastHours;
                    console.log(`  ${cauldronId}: Safe for entire forecast (${currentLevel.toFixed(0)}L ‚Üí ${predictedLevel.toFixed(0)}L, safety: ${safetyLevel.toFixed(0)}L)`);
                } else if (netFillRate <= 0) {
                    // No fill rate
                    requiredCollectionFrequency = forecastHours;
                } else {
                    // Will exceed safety - calculate how often to collect to keep it below safety at end of forecast
                    // We need to keep level below safetyLevel after forecastHours
                    // If we collect every X hours, the level will be: currentLevel + (netFillRate * X)
                    // We want: currentLevel + (netFillRate * X) <= safetyLevel
                    // So: X <= (safetyLevel - currentLevel) / netFillRate
                    requiredCollectionFrequency = (safetyLevel - currentLevel) / netFillRate;
                    
                    // Ensure minimum 0.5 hours (30 minutes) for realistic route cycles
                    if (requiredCollectionFrequency < 0.5) {
                        console.log(`  ${cauldronId}: Very urgent - only ${requiredCollectionFrequency.toFixed(2)} hrs until safety (${currentLevel.toFixed(0)}L ‚Üí ${safetyLevel.toFixed(0)}L), fill rate ${fillRatePerHour.toFixed(1)}L/hr`);
                        requiredCollectionFrequency = 0.5;
                    }
                }
                
                // Calculate when next collection is due
                const nextCollectionDue = requiredCollectionFrequency;
                
                predictions.push({
                    cauldron: cauldronId,
                    location: { lat: cauldron.latitude, lng: cauldron.longitude },
                    currentLevel,
                    fillRate: fillRatePerHour,
                    drainRate: drainRatePerHour,
                    netFillRate,
                    predictedLevel,
                    maxVolume,
                    safetyLevel,
                    requiredCollectionFrequency, // Hours between collections needed
                    nextCollectionDue, // Hours until next collection needed
                    status: 'Protected' // All cauldrons are protected by proactive scheduling
                });
            });
            
            // Sort by most frequent collection needs (shortest frequency first)
            return predictions.sort((a, b) => a.requiredCollectionFrequency - b.requiredCollectionFrequency);
        }
        
        function calculateOptimalWitchesIteratively(forecastHours, safetyMargin) {
            const WITCH_CAPACITY = 200; // Liters - max a witch can carry at once
            
            // Step 1: Create optimal routes using TSP (ignoring time constraints initially)
            const baseRoutes = createOptimalRoutes();
            
            console.log(`Created ${baseRoutes.length} base routes using TSP optimization`);
            
            // Step 2: Simulate and add witches iteratively until no overflow AT END of forecast period
            let numWitches = baseRoutes.length; // Start with one witch per route
            let overflow = true;
            let iteration = 0;
            const MAX_ITERATIONS = 20;
            
            while (overflow && iteration < MAX_ITERATIONS) {
                iteration++;
                console.log(`\nIteration ${iteration}: Testing with ${numWitches} witches...`);
                
                const simulation = simulateCollectionToForecastEnd(baseRoutes, numWitches, forecastHours, safetyMargin, WITCH_CAPACITY);
                
                if (simulation.overflowOccurred) {
                    console.log(`  ‚ùå Overflow at forecast end in ${simulation.overflowCauldrons.length} cauldrons: ${simulation.overflowCauldrons.join(', ')}`);
                    numWitches++;
                } else {
                    console.log(`  ‚úÖ No overflow! All cauldrons below ${(safetyMargin * 100).toFixed(0)}% at forecast end with ${numWitches} witches`);
                    overflow = false;
                }
            }
            
            if (iteration >= MAX_ITERATIONS) {
                console.warn(`‚ö†Ô∏è Reached max iterations. Using ${numWitches} witches.`);
            }
            
            // Step 3: Create final witch assignments
            const finalRoutes = assignWitchesToRoutes(baseRoutes, numWitches);
            const predictions = createPredictions(forecastHours, safetyMargin);
            
            return { routes: finalRoutes, totalWitches: numWitches, predictions };
        }
        
        function createOptimalRoutes() {
            // TSP-based route optimization - create efficient routes without time constraints
            const routes = [];
            const unvisited = new Set(cauldrons.map(c => c.id));
            
            while (unvisited.size > 0) {
                const route = [];
                let currentPos = market ? { lat: market.latitude, lng: market.longitude } : null;
                let currentId = 'market';
                let totalDistance = 0;
                let totalTime = 0;
                
                // Build route using nearest neighbor (max 8 cauldrons)
                while (unvisited.size > 0 && route.length < 8) {
                    let nearest = null;
                    let minDist = Infinity;
                    
                    unvisited.forEach(cauldronId => {
                        const cauldron = cauldrons.find(c => c.id === cauldronId);
                        if (cauldron && currentPos) {
                            const dist = calculateDistance(currentPos.lat, currentPos.lng, cauldron.latitude, cauldron.longitude);
                            if (dist < minDist) {
                                minDist = dist;
                                nearest = { cauldronId, cauldron, dist };
                            }
                        }
                    });
                    
                    if (nearest) {
                        const travelTime = calculateTravelTime(currentPos, 
                            { lat: nearest.cauldron.latitude, lng: nearest.cauldron.longitude }, 
                            currentId, nearest.cauldronId);
                        
                        route.push({
                            cauldron: nearest.cauldronId,
                            location: { lat: nearest.cauldron.latitude, lng: nearest.cauldron.longitude }
                        });
                        
                        unvisited.delete(nearest.cauldronId);
                        totalDistance += nearest.dist;
                        totalTime += travelTime + 5; // Travel + 5 min collection
                        currentPos = { lat: nearest.cauldron.latitude, lng: nearest.cauldron.longitude };
                        currentId = nearest.cauldronId;
                    } else {
                        break;
                    }
                }
                
                // Return to market
                if (currentPos && market) {
                    const returnDist = calculateDistance(currentPos.lat, currentPos.lng, market.latitude, market.longitude);
                    const returnTime = calculateTravelTime(currentPos, 
                        { lat: market.latitude, lng: market.longitude }, currentId, 'market');
                    totalDistance += returnDist;
                    totalTime += returnTime + 15; // Return + 15 min drop-off
                }
                
                routes.push({
                    cauldrons: route,
                    distance: totalDistance,
                    time: totalTime, // minutes
                    cycleTime: totalTime / 60 // hours
                });
            }
            
            return routes;
        }
        
        function simulateCollectionToForecastEnd(routes, numWitches, forecastHours, safetyMargin, witchCapacity) {
            // Simulate the collection process and check if cauldrons are below safety at FORECAST END
            const cauldronLevels = {};
            cauldrons.forEach(c => {
                cauldronLevels[c.id] = currentLevels[c.id] || 0;
            });
            
            const overflowCauldrons = [];
            
            // Distribute witches across routes (proportional to route cycle time)
            const totalCycleTime = routes.reduce((sum, r) => sum + r.cycleTime, 0);
            const witchesPerRoute = routes.map((route, idx) => {
                // Longer routes get more witches
                const proportion = route.cycleTime / totalCycleTime;
                const assigned = Math.max(1, Math.round(numWitches * proportion));
                return Math.min(assigned, Math.floor(numWitches / routes.length) + 2); // Cap per route
            });
            
            // Adjust to match exact total
            let totalAssigned = witchesPerRoute.reduce((sum, w) => sum + w, 0);
            let routeIdx = 0;
            while (totalAssigned < numWitches) {
                witchesPerRoute[routeIdx % routes.length]++;
                totalAssigned++;
                routeIdx++;
            }
            while (totalAssigned > numWitches) {
                const idx = witchesPerRoute.findIndex(w => w > 1);
                if (idx >= 0) {
                    witchesPerRoute[idx]--;
                    totalAssigned--;
                } else break;
            }
            
            console.log(`  Witch distribution: ${witchesPerRoute.join(', ')} across ${routes.length} routes`);
            
            // Calculate collection frequency for each route based on assigned witches
            routes.forEach((route, idx) => {
                const witches = witchesPerRoute[idx];
                if (witches === 0) return;
                
                // With multiple witches on a route, they cycle through it
                const cycleTimeHours = route.cycleTime;
                const hoursBetweenCollections = cycleTimeHours / witches;
                
                console.log(`    Route ${idx + 1}: ${witches} witch(es), ${cycleTimeHours.toFixed(2)}h cycle ‚Üí collect every ${hoursBetweenCollections.toFixed(2)}h`);
            });
            
            // Simulate fill levels over forecast period
            const timeStep = 0.1; // hours (6 minutes)
            for (let t = timeStep; t <= forecastHours; t += timeStep) {
                // Fill all cauldrons
                cauldrons.forEach(c => {
                    const fillRate = (cauldronFillRates[c.id] || 0.5) * 60; // L/hr
                    cauldronLevels[c.id] += fillRate * timeStep;
                    
                    // Cap at max volume
                    const maxVolume = c.max_volume || 1000;
                    if (cauldronLevels[c.id] > maxVolume) {
                        cauldronLevels[c.id] = maxVolume;
                    }
                });
                
                // Witches collect on their schedules
                routes.forEach((route, routeIdx) => {
                    const witches = witchesPerRoute[routeIdx];
                    if (witches === 0) return;
                    
                    const cycleTimeHours = route.cycleTime;
                    const hoursBetweenCollections = cycleTimeHours / witches;
                    
                    // Check if it's time for this route to collect
                    if (Math.abs(t % hoursBetweenCollections) < timeStep * 0.5) {
                        let witchLoad = 0;
                        route.cauldrons.forEach(c => {
                            const cauldronId = c.cauldron;
                            const currentLevel = cauldronLevels[cauldronId];
                            const amountToCollect = Math.min(currentLevel, witchCapacity - witchLoad);
                            
                            if (amountToCollect > 0) {
                                cauldronLevels[cauldronId] -= amountToCollect;
                                witchLoad += amountToCollect;
                            }
                            
                            if (witchLoad >= witchCapacity) {
                                return; // Witch is full
                            }
                        });
                    }
                });
            }
            
            // Check final levels against safety threshold
            cauldrons.forEach(c => {
                const maxVolume = c.max_volume || 1000;
                const safetyLevel = maxVolume * safetyMargin;
                const finalLevel = cauldronLevels[c.id];
                
                if (finalLevel > safetyLevel) {
                    overflowCauldrons.push(c.id);
                    console.log(`    ‚ö†Ô∏è ${c.id}: ${finalLevel.toFixed(0)}L > ${safetyLevel.toFixed(0)}L safety (${(safetyMargin * 100).toFixed(0)}%)`);
                }
            });
            
            return {
                overflowOccurred: overflowCauldrons.length > 0,
                overflowCauldrons,
                finalLevels: cauldronLevels
            };
        }
        
        function assignWitchesToRoutes(baseRoutes, numWitches) {
            // Create final witch assignments
            const routes = [];
            let witchCounter = 1;
            
            baseRoutes.forEach((route, idx) => {
                const baseWitches = Math.floor(numWitches / baseRoutes.length);
                const extra = idx < (numWitches % baseRoutes.length) ? 1 : 0;
                const witchesForRoute = baseWitches + extra;
                
                for (let w = 0; w < witchesForRoute; w++) {
                    routes.push({
                        witchId: witchCounter++,
                        cauldrons: route.cauldrons,
                        distance: route.distance,
                        time: route.time,
                        collections: route.cauldrons.length,
                        witchesNeeded: 1
                    });
                }
            });
            
            return routes;
        }
        
        function createPredictions(forecastHours, safetyMargin) {
            // Create prediction data for display
            const predictions = [];
            
            cauldrons.forEach(cauldron => {
                const cauldronId = cauldron.id;
                const maxVolume = cauldron.max_volume || 1000;
                const fillRate = (cauldronFillRates[cauldronId] || 0.5) * 60; // L/hr
                const drainRate = (cauldronDrainRates[cauldronId] || (fillRate / 2));
                const currentLevel = currentLevels[cauldronId] || 0;
                const predictedLevel = currentLevel + (fillRate * forecastHours);
                const safetyLevel = maxVolume * safetyMargin;
                
                predictions.push({
                    cauldron: cauldronId,
                    location: { lat: cauldron.latitude, lng: cauldron.longitude },
                    currentLevel,
                    fillRate,
                    drainRate,
                    netFillRate: fillRate,
                    predictedLevel,
                    maxVolume,
                    safetyLevel,
                    requiredCollectionFrequency: 0, // Calculated by simulation
                    nextCollectionDue: 0,
                    status: 'Protected'
                });
            });
            
            return predictions;
        }
        
        // Helper function to get travel time from network data
        function getTravelTime(fromId, toId) {
            // Check if we have network data with travel times
            if (!network || network.length === 0) {
                // Fallback to Haversine distance calculation
                return null;
            }
            
            // Look for direct edge in network (bidirectional check)
            const edge = network.find(e => 
                (e.from_node === fromId && e.to_node === toId) ||
                (e.from_node === toId && e.to_node === fromId)
            );
            
            if (edge) {
                return edge.travel_time_minutes || edge.travel_time || null;
            }
            
            // No direct edge - try to find shortest path through network
            return findShortestPathTime(fromId, toId);
        }
        
        // Dijkstra's algorithm to find shortest path through network
        function findShortestPathTime(startId, endId) {
            if (!network || network.length === 0) return null;
            
            // Build adjacency list from network
            const graph = {};
            network.forEach(edge => {
                const from = edge.from_node;
                const to = edge.to_node;
                const time = edge.travel_time_minutes || edge.travel_time || 0;
                
                if (!graph[from]) graph[from] = [];
                if (!graph[to]) graph[to] = [];
                
                graph[from].push({ node: to, time: time });
                graph[to].push({ node: from, time: time }); // Bidirectional
            });
            
            // Check if both nodes exist in graph
            if (!graph[startId] || !graph[endId]) return null;
            
            // Dijkstra's algorithm
            const distances = {};
            const visited = new Set();
            const queue = [{ node: startId, dist: 0 }];
            
            // Initialize distances
            Object.keys(graph).forEach(node => {
                distances[node] = Infinity;
            });
            distances[startId] = 0;
            
            while (queue.length > 0) {
                // Get node with minimum distance
                queue.sort((a, b) => a.dist - b.dist);
                const { node: current, dist: currentDist } = queue.shift();
                
                if (visited.has(current)) continue;
                visited.add(current);
                
                // Found the destination
                if (current === endId) {
                    return currentDist;
                }
                
                // Check neighbors
                if (graph[current]) {
                    graph[current].forEach(({ node: neighbor, time }) => {
                        if (!visited.has(neighbor)) {
                            const newDist = currentDist + time;
                            if (newDist < distances[neighbor]) {
                                distances[neighbor] = newDist;
                                queue.push({ node: neighbor, dist: newDist });
                            }
                        }
                    });
                }
            }
            
            // No path found
            return null;
        }
        
        // Helper function to calculate travel time between two points
        function calculateTravelTime(fromPos, toPos, fromId, toId) {
            // ONLY use network travel times - no distance fallback
            const networkTime = getTravelTime(fromId, toId);
            if (networkTime !== null && !isNaN(networkTime) && networkTime > 0) {
                console.log(`  ‚úì Network path ${fromId} -> ${toId}: ${networkTime.toFixed(1)} min`);
                return networkTime;
            }
            
            // If no network path exists, this is an error - routes should only use network
            console.error(`  ‚ùå ERROR: No network path exists for ${fromId} -> ${toId}!`);
            console.error(`     This means the network data is incomplete or nodes are disconnected.`);
            
            // Return a penalty time to indicate this route is invalid
            return 999; // Large penalty to discourage this route
        }
        
        function predictCauldronLevels(forecastHours, safetyMargin) {
            const predictions = [];
            
            console.log(`Predicting for ${cauldrons.length} cauldrons with safety margin ${(safetyMargin * 100).toFixed(0)}%`);
            
            cauldrons.forEach(cauldron => {
                const cauldronId = cauldron.id;
                const maxVolume = cauldron.max_volume || 1000;
                
                // Use fill rate (L/min) - convert to L/hr
                const fillRate = cauldronFillRates[cauldronId] || 0.5; // L/min
                const fillRatePerHour = fillRate * 60; // L/hr
                
                // Use drain rate (L/min) if available - convert to L/hr
                const drainRate = cauldronDrainRates[cauldronId] || (fillRate * 2); // L/min
                const drainRatePerHour = drainRate * 60; // L/hr
                
                // Get current level
                const currentLevel = currentLevels[cauldronId] || 0;
                
                // Net fill rate (assuming continuous fill)
                const netFillRate = fillRatePerHour;
                
                // Calculate safety level
                const safetyLevel = maxVolume * safetyMargin;
                
                // Calculate REQUIRED collection frequency to stay below safety threshold AFTER forecast period
                // Predicted level after forecast period (without collection)
                const predictedLevel = currentLevel + (netFillRate * forecastHours);
                
                let requiredCollectionFrequency;
                if (predictedLevel <= safetyLevel) {
                    // Won't exceed safety threshold during forecast period - no urgent collection needed
                    requiredCollectionFrequency = forecastHours;
                    console.log(`  ${cauldronId}: Safe for entire forecast (${currentLevel.toFixed(0)}L ‚Üí ${predictedLevel.toFixed(0)}L, safety: ${safetyLevel.toFixed(0)}L)`);
                } else if (netFillRate <= 0) {
                    // No fill rate
                    requiredCollectionFrequency = forecastHours;
                } else {
                    // Will exceed safety - calculate how often to collect to keep it below safety at end of forecast
                    // We need to keep level below safetyLevel after forecastHours
                    // If we collect every X hours, the level will be: currentLevel + (netFillRate * X)
                    // We want: currentLevel + (netFillRate * X) <= safetyLevel
                    // So: X <= (safetyLevel - currentLevel) / netFillRate
                    requiredCollectionFrequency = (safetyLevel - currentLevel) / netFillRate;
                    
                    // Ensure minimum 0.5 hours (30 minutes) for realistic route cycles
                    if (requiredCollectionFrequency < 0.5) {
                        console.log(`  ${cauldronId}: Very urgent - only ${requiredCollectionFrequency.toFixed(2)} hrs until safety (${currentLevel.toFixed(0)}L ‚Üí ${safetyLevel.toFixed(0)}L), fill rate ${fillRatePerHour.toFixed(1)}L/hr`);
                        requiredCollectionFrequency = 0.5;
                    } else {
                        console.log(`  ${cauldronId}: Will reach safety in ${requiredCollectionFrequency.toFixed(2)} hrs (${currentLevel.toFixed(0)}L ‚Üí ${safetyLevel.toFixed(0)}L)`);
                    }
                }
                
                // Calculate when next collection is due (to stay below safety margin)
                const nextCollectionDue = requiredCollectionFrequency;
                
                predictions.push({
                    cauldron: cauldronId,
                    location: { lat: cauldron.latitude, lng: cauldron.longitude },
                    currentLevel,
                    fillRate: fillRatePerHour,
                    drainRate: drainRatePerHour,
                    netFillRate,
                    predictedLevel,
                    maxVolume,
                    safetyLevel,
                    requiredCollectionFrequency, // Hours between collections needed
                    nextCollectionDue, // Hours until next collection needed
                    status: 'Protected' // All cauldrons are protected by proactive scheduling
                });
            });
            
            // Sort by most frequent collection needs (shortest frequency first)
            return predictions.sort((a, b) => a.requiredCollectionFrequency - b.requiredCollectionFrequency);
        }
        
        function calculateOptimalRoutes(predictions, forecastHours) {
            // Include ALL cauldrons - we're preventing overflow, not reacting to it
            // Sort by required collection frequency (most frequent first)
            const sortedPredictions = [...predictions].sort((a, b) => 
                a.requiredCollectionFrequency - b.requiredCollectionFrequency
            );
            
            if (sortedPredictions.length === 0) {
                return [];
            }
            
            // TSP-like greedy algorithm for route optimization
            const routes = [];
            const unvisited = new Set(sortedPredictions.map(p => p.cauldron));
            
            while (unvisited.size > 0) {
                const route = [];
                let currentPos = market ? { lat: market.latitude, lng: market.longitude } : null;
                let currentId = 'market';
                let totalDistance = 0;
                let totalTime = 0;
                
                // Start from market, visit nearest unvisited cauldrons
                while (unvisited.size > 0 && route.length < 8) { // Max 8 cauldrons per route
                    let nearest = null;
                    let minDist = Infinity;
                    
                    unvisited.forEach(cauldronId => {
                        const pred = predictions.find(p => p.cauldron === cauldronId);
                        if (pred && currentPos) {
                            const dist = calculateDistance(currentPos.lat, currentPos.lng, pred.location.lat, pred.location.lng);
                            // Prioritize cauldrons with shorter collection frequency needs
                            const adjustedDist = dist * (pred.requiredCollectionFrequency / 10);
                            if (adjustedDist < minDist) {
                                minDist = adjustedDist;
                                nearest = { cauldronId, pred, dist };
                            }
                        }
                    });
                    
                    if (nearest) {
                        // Calculate actual travel time using network data
                        const travelTime = calculateTravelTime(currentPos, nearest.pred.location, currentId, nearest.cauldronId);
                        
                        route.push({
                            cauldron: nearest.cauldronId,
                            location: nearest.pred.location,
                            requiredFrequency: nearest.pred.requiredCollectionFrequency,
                            nextCollectionDue: nearest.pred.nextCollectionDue
                        });
                        unvisited.delete(nearest.cauldronId);
                        totalDistance += nearest.dist;
                        totalTime += travelTime; // Use actual network travel time
                        totalTime += 5; // 5 min collection time per cauldron
                        currentPos = nearest.pred.location;
                        currentId = nearest.cauldronId;
                    } else {
                        break;
                    }
                }
                
                // Return to market and add 15-minute drop-off time
                if (currentPos && market) {
                    const returnDist = calculateDistance(currentPos.lat, currentPos.lng, market.latitude, market.longitude);
                    const returnTime = calculateTravelTime(currentPos, { lat: market.latitude, lng: market.longitude }, currentId, 'market');
                    totalDistance += returnDist;
                    totalTime += returnTime; // Use actual network travel time
                    totalTime += 15; // 15 minutes to drop off potions at market
                }
                
                // Calculate how often this route needs to run (based on most demanding cauldron)
                const minFrequency = route.length > 0 ? 
                    Math.min(...route.map(c => c.requiredFrequency)) : 
                    forecastHours;
                
                routes.push({
                    cauldrons: route,
                    distance: totalDistance,
                    time: totalTime,
                    collections: route.length,
                    requiredFrequency: minFrequency, // Must complete within this time
                    cycleTime: totalTime / 60 // Convert to hours for comparison
                });
            }
            
            // Ensure all routes can complete within their required frequency
            // If cycle time > required frequency, we need multiple witches on that route
            routes.forEach((route, idx) => {
                if (route.cycleTime > route.requiredFrequency) {
                    route.witchesNeeded = Math.ceil(route.cycleTime / route.requiredFrequency);
                    console.log(`  Route ${idx + 1}: Cycle ${route.cycleTime.toFixed(2)}h > Required ${route.requiredFrequency.toFixed(2)}h ‚Üí ${route.witchesNeeded} witches needed`);
                } else {
                    route.witchesNeeded = 1;
                }
            });
            
            return routes;
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula for distance in km
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function calculateMinimumWitches(routes, forecastHours) {
            if (routes.length === 0) return 0;
            
            // Sum up the witches needed for all routes
            // Each route may need multiple witches if cycle time exceeds required frequency
            const totalWitches = routes.reduce((sum, route) => sum + route.witchesNeeded, 0);
            
            return totalWitches;
        }
        
        function displayOptimizationStats(minWitches, routes, predictions, forecastHours) {
            const totalCauldrons = predictions.length;
            const totalDistance = routes.reduce((sum, r) => sum + r.distance, 0);
            const avgCycleTime = routes.length > 0 ? routes.reduce((sum, r) => sum + r.time, 0) / routes.length : 0;
            const maxCycleTime = routes.length > 0 ? Math.max(...routes.map(r => r.time)) : 0;
            
            // Calculate average collection frequency needed
            const avgFrequency = predictions.length > 0 ? 
                predictions.reduce((sum, p) => sum + p.requiredCollectionFrequency, 0) / predictions.length : 0;
            
            document.getElementById('optimization-stats').innerHTML = `
                <div class="stat-card" style="background: #667eea;">
                    <h3>${minWitches}</h3>
                    <p>Witches Required (24/7)</p>
                </div>
                <div class="stat-card">
                    <h3>${routes.length}</h3>
                    <p>Continuous Routes</p>
                </div>
                <div class="stat-card">
                    <h3>${totalDistance.toFixed(1)} km</h3>
                    <p>Total Distance per Cycle</p>
                </div>
                <div class="stat-card" style="background: #28a745;">
                    <h3>${totalCauldrons}</h3>
                    <p>All Cauldrons Protected</p>
                </div>
                <div class="stat-card">
                    <h3>${avgCycleTime.toFixed(0)} min</h3>
                    <p>Avg Cycle Time</p>
                </div>
                <div class="stat-card">
                    <h3>${avgFrequency.toFixed(1)} hrs</h3>
                    <p>Avg Collection Frequency</p>
                </div>
            `;
        }
        
        function displayWitchSchedule(routes) {
            const tbody = document.getElementById('witch-schedule-tbody');
            let witchCounter = 1;
            
            tbody.innerHTML = routes.map((route) => {
                const cauldronList = route.cauldrons.map(c => c.cauldron).join(', ');
                const routeSequence = route.cauldrons.map(c => c.cauldron).join(' ‚Üí ');
                const cyclesPerDay = (24 * 60) / route.time;
                const witchesNeeded = route.witchesNeeded || 1;
                
                // Create a row for each witch needed on this route
                let rows = '';
                for (let w = 0; w < witchesNeeded; w++) {
                    rows += `
                        <tr>
                            <td><strong>Witch-${witchCounter++}</strong></td>
                            <td>${cauldronList}</td>
                            <td>${route.distance.toFixed(1)} km</td>
                            <td>${route.time.toFixed(0)} min (${cyclesPerDay.toFixed(1)} cycles/day)${witchesNeeded > 1 ? ` - ${witchesNeeded} witches on this route` : ''}</td>
                            <td>${route.collections}</td>
                            <td style="font-size: 12px;">Market ‚Üí ${routeSequence} ‚Üí Market (+ 15min drop-off)</td>
                        </tr>
                    `;
                }
                return rows;
            }).join('');
        }
        
        function displayCauldronPredictions(predictions) {
            const tbody = document.getElementById('cauldron-predictions-tbody');
            tbody.innerHTML = predictions.map(pred => {
                // Check if predicted level exceeds safety threshold (warning) or max (critical)
                let statusColor = '#28a745'; // Green - safe
                let status = 'Protected';
                
                if (pred.predictedLevel > pred.maxVolume) {
                    statusColor = '#dc3545'; // Red - will overflow
                    status = 'Will Overflow';
                } else if (pred.predictedLevel > pred.safetyLevel) {
                    statusColor = '#ffc107'; // Yellow - above safety but below max
                    status = 'Above Safety';
                }
                
                // Format collection frequency (not used in simulation, just for display)
                const frequency = 'Continuous';
                const nextDue = 'As needed';
                    
                return `
                    <tr>
                        <td><strong>${pred.cauldron}</strong></td>
                        <td>${pred.currentLevel.toFixed(1)}L</td>
                        <td>${pred.fillRate.toFixed(1)}L/hr</td>
                        <td>${pred.drainRate.toFixed(1)}L/hr</td>
                        <td>${pred.predictedLevel.toFixed(1)}L / ${pred.maxVolume}L${pred.predictedLevel > pred.safetyLevel ? ` ‚ö†Ô∏è (safety: ${pred.safetyLevel.toFixed(0)}L)` : ''}</td>
                        <td>${frequency}</td>
                        <td>${nextDue}</td>
                        <td style="color: ${statusColor}; font-weight: bold;">${status}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function visualizeRoutesOnMap(routes) {
            // Clear existing route polylines
            routePolylines.forEach(polyline => optimizationMap.removeLayer(polyline));
            routePolylines = [];
            
            // Add market marker
            if (market) {
                L.marker([market.latitude, market.longitude], {
                    icon: L.divIcon({
                        className: 'market-marker',
                        html: 'üè∞',
                        iconSize: [30, 30]
                    })
                }).addTo(optimizationMap).bindPopup('<b>Market</b>');
            }
            
            // Add cauldron markers
            cauldrons.forEach(cauldron => {
                const icon = L.divIcon({
                    className: 'cauldron-marker',
                    html: '‚öóÔ∏è',
                    iconSize: [25, 25]
                });
                L.marker([cauldron.latitude, cauldron.longitude], { icon })
                    .addTo(optimizationMap)
                    .bindPopup(`<b>${cauldron.id}</b>`);
            });
            
            // Draw routes with different colors
            const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe', '#43e97b', '#fa709a', '#fee140'];
            
            routes.forEach((route, idx) => {
                const color = colors[idx % colors.length];
                const coords = [];
                
                // Start from market
                if (market) {
                    coords.push([market.latitude, market.longitude]);
                }
                
                // Add each cauldron in route
                route.cauldrons.forEach(c => {
                    coords.push([c.location.lat, c.location.lng]);
                });
                
                // Return to market
                if (market) {
                    coords.push([market.latitude, market.longitude]);
                }
                
                // Draw polyline
                const polyline = L.polyline(coords, {
                    color: color,
                    weight: 3,
                    opacity: 0.7
                }).addTo(optimizationMap);
                
                polyline.bindPopup(`<b>Witch-${idx + 1}</b><br>Distance: ${route.distance.toFixed(1)} km<br>Time: ${route.time.toFixed(0)} min`);
                routePolylines.push(polyline);
            });
            
            // Fit map to show all routes
            if (routePolylines.length > 0) {
                const group = L.featureGroup(routePolylines);
                optimizationMap.fitBounds(group.getBounds(), { padding: [50, 50] });
            }
        }

        // ========================================
        // 3D VISUALIZATION WITH THREE.JS
        // ========================================

        let scene3d, camera3d, renderer3d, controls3d;
        let cauldron3dObjects = [];
        let particles3d = [];
        let animationId3d = null;
        let isAnimating3d = true;
        let showParticles3d = true;
        let viewMode3d = 0; // 0: perspective, 1: top, 2: side

        function init3DVisualization() {
            const container = document.getElementById('threejs-canvas');
            if (!container) {
                console.error('3D container not found!');
                return;
            }

            if (typeof THREE === 'undefined') {
                console.error('THREE.js not loaded!');
                container.innerHTML = '<div style="color: white; padding: 40px; text-align: center;">Error: THREE.js library failed to load. Please refresh the page.</div>';
                return;
            }

            console.log('Initializing 3D visualization...');

            // Hide loading message
            const loadingEl = document.getElementById('threejs-loading');
            if (loadingEl) loadingEl.style.display = 'none';

            // Scene setup
            scene3d = new THREE.Scene();
            scene3d.background = new THREE.Color(0x0c0b2f);
            scene3d.fog = new THREE.Fog(0x0c0b2f, 50, 200);

            // Camera setup - better initial position
            camera3d = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera3d.position.set(40, 35, 40);
            camera3d.lookAt(0, 5, 0);

            // Renderer setup
            renderer3d = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer3d.setSize(container.clientWidth, container.clientHeight);
            renderer3d.setPixelRatio(window.devicePixelRatio);
            renderer3d.shadowMap.enabled = true;
            renderer3d.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer3d.domElement);

            // Orbit controls
            controls3d = new THREE.OrbitControls(camera3d, renderer3d.domElement);
            controls3d.enableDamping = true;
            controls3d.dampingFactor = 0.05;
            controls3d.maxPolarAngle = Math.PI / 2;
            controls3d.minDistance = 10;
            controls3d.maxDistance = 100;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404070, 0.6);
            scene3d.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene3d.add(directionalLight);

            // Add magical purple point lights
            const light1 = new THREE.PointLight(0x667eea, 1, 50);
            light1.position.set(15, 10, 15);
            scene3d.add(light1);

            const light2 = new THREE.PointLight(0x764ba2, 1, 50);
            light2.position.set(-15, 10, -15);
            scene3d.add(light2);

            // Create ground plane with grid
            const gridHelper = new THREE.GridHelper(100, 20, 0x667eea, 0x444466);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene3d.add(gridHelper);

            // Add starfield background
            createStarfield();

            // Load and visualize cauldron data
            load3DCauldronData();

            // Handle window resize
            window.addEventListener('resize', onWindowResize3D);

            // Start animation
            animate3D();
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];

            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 200;
                const y = Math.random() * 100 + 20;
                const z = (Math.random() - 0.5) * 200;
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            const stars = new THREE.Points(geometry, material);
            scene3d.add(stars);
        }

        async function load3DCauldronData() {
            try {
                console.log('Loading 3D cauldron data...');
                const [cauldronRes, levelsRes, marketRes] = await Promise.all([
                    fetch('/api/cauldrons'),
                    fetch('/api/current-levels'),
                    fetch('/api/market')
                ]);

                const cauldrons = await cauldronRes.json();
                const levelsData = await levelsRes.json();
                const marketData = await marketRes.json();

                console.log('Cauldrons:', cauldrons);
                console.log('Levels:', levelsData);

                if (!cauldrons || cauldrons.error) {
                    console.error('No cauldron data available');
                    return;
                }

                const levels = levelsData.levels || {};

                // Create 3D cauldrons
                cauldrons.forEach(cauldron => {
                    const level = levels[cauldron.id] || 50;
                    const fillPercent = (level / cauldron.capacity) * 100;
                    create3DCauldron(cauldron, fillPercent);
                });

                console.log('Created', cauldron3dObjects.length, '3D cauldrons');

                // Create market
                if (marketData && !marketData.error) {
                    create3DMarket(marketData);
                    console.log('Created 3D market');
                }

                // Create connection lines
                cauldron3dObjects.forEach((obj1, i) => {
                    cauldron3dObjects.forEach((obj2, j) => {
                        if (i < j) {
                            createConnectionLine(obj1.position, obj2.position);
                        }
                    });
                });

                console.log('3D scene setup complete!');

            } catch (error) {
                console.error('Error loading 3D data:', error);
            }
        }

        function create3DCauldron(cauldron, fillPercent) {
            const group = new THREE.Group();

            // Use real lat/lng coordinates - normalized to 3D space
            // Scale factor to make distances visible but reasonable
            const scaleFactor = 3000; // Adjust this to change spread

            // Market center coordinates (our origin)
            const marketLat = 33.2148;
            const marketLng = -97.13;

            // Convert lat/lng offset to 3D coordinates
            // X = longitude difference (East-West)
            // Z = latitude difference (North-South)
            const x = (cauldron.longitude - marketLng) * scaleFactor;
            const z = (marketLat - cauldron.latitude) * scaleFactor; // Inverted because Z+ is south in 3D

            console.log(`Cauldron ${cauldron.id} positioned at (${x.toFixed(1)}, ${z.toFixed(1)})`);

            // Cauldron base (cylinder) - larger size
            const baseHeight = 3;
            const cauldronRadius = 2;
            const baseGeometry = new THREE.CylinderGeometry(cauldronRadius, cauldronRadius * 0.8, baseHeight, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: 0x333344,
                shininess: 60
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);

            // Potion liquid (height based on fill percentage) - taller
            const liquidHeight = (fillPercent / 100) * 5;
            const liquidGeometry = new THREE.CylinderGeometry(cauldronRadius * 0.9, cauldronRadius * 0.7, liquidHeight, 16);

            // Color based on fill level
            let color;
            if (fillPercent > 90) color = 0xdc143c; // red
            else if (fillPercent > 75) color = 0xff8c00; // orange
            else if (fillPercent > 60) color = 0xffd700; // yellow
            else if (fillPercent > 40) color = 0xadff2f; // greenyellow
            else color = 0x90ee90; // lightgreen

            const liquidMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
            liquid.position.y = baseHeight / 2 + liquidHeight / 2;
            group.add(liquid);

            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(cauldronRadius * 1.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.15
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = baseHeight / 2 + liquidHeight / 2;
            group.add(glow);

            // Add text label (cauldron ID)
            createTextLabel(cauldron.id, group, baseHeight + liquidHeight + 2);

            // Position the group
            group.position.set(x, 0, z);
            group.userData = {
                cauldron,
                fillPercent,
                liquid,
                glow,
                color,
                type: 'cauldron'
            };
            scene3d.add(group);
            cauldron3dObjects.push(group);

            // Create particle effect
            if (showParticles3d) {
                createPotionParticles(group.position, color);
            }
        }

        // Create text labels using canvas texture
        function createTextLabel(text, parent, yOffset) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 32px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 2, 1);
            sprite.position.set(0, yOffset, 0);
            parent.add(sprite);
        }

        function create3DMarket(market) {
            const group = new THREE.Group();

            // Market at center (origin of our coordinate system)
            const x = 0;
            const z = 0;

            console.log(`Market positioned at center (0, 0)`);

            // Market building (box) - larger
            const geometry = new THREE.BoxGeometry(6, 8, 6);
            const material = new THREE.MeshPhongMaterial({
                color: 0xff6b6b,
                emissive: 0xc92a2a,
                emissiveIntensity: 0.3
            });
            const building = new THREE.Mesh(geometry, material);
            building.position.y = 4;
            building.castShadow = true;
            group.add(building);

            // Market roof (cone) - larger
            const roofGeometry = new THREE.ConeGeometry(5, 4, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: 0xc92a2a,
                emissive: 0xa01a1a,
                emissiveIntensity: 0.2
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 10;
            roof.rotation.y = Math.PI / 4;
            group.add(roof);

            // Add glowing orb on top
            const orbGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const orbMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            orb.position.y = 12.5;
            group.add(orb);

            // Add market label
            createTextLabel('üè™ MARKET', group, 14);

            group.position.set(x, 0, z);
            group.userData = { type: 'market', market };
            scene3d.add(group);
        }

        function createConnectionLine(pos1, pos2) {
            const material = new THREE.LineBasicMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.2
            });

            const points = [];
            points.push(new THREE.Vector3(pos1.x, pos1.y + 1, pos1.z));
            points.push(new THREE.Vector3(pos2.x, pos2.y + 1, pos2.z));

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene3d.add(line);
        }

        function createPotionParticles(position, color) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * 2,
                    position.y + Math.random() * 5,
                    position.z + (Math.random() - 0.5) * 2
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.02,
                    Math.random() * 0.05 + 0.02,
                    (Math.random() - 0.5) * 0.02
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.2,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData = { velocities, basePosition: position.clone() };
            scene3d.add(particleSystem);
            particles3d.push(particleSystem);
        }

        function animate3D() {
            if (!isAnimating3d) return;

            animationId3d = requestAnimationFrame(animate3D);

            // Update controls
            if (controls3d) controls3d.update();

            // Animate cauldrons (pulsing glow)
            const time = Date.now() * 0.001;
            cauldron3dObjects.forEach((obj, i) => {
                const glow = obj.userData.glow;
                if (glow) {
                    glow.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.1);
                }
            });

            // Animate particles
            particles3d.forEach(system => {
                const positions = system.geometry.attributes.position.array;
                const velocities = system.userData.velocities;
                const basePos = system.userData.basePosition;

                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];

                    // Reset particle if too far
                    if (positions[i + 1] > basePos.y + 10) {
                        positions[i] = basePos.x + (Math.random() - 0.5) * 2;
                        positions[i + 1] = basePos.y;
                        positions[i + 2] = basePos.z + (Math.random() - 0.5) * 2;
                    }
                }

                system.geometry.attributes.position.needsUpdate = true;
            });

            // Render
            if (renderer3d && scene3d && camera3d) {
                renderer3d.render(scene3d, camera3d);
            }
        }

        function onWindowResize3D() {
            const container = document.getElementById('threejs-canvas');
            if (!container || !camera3d || !renderer3d) return;

            camera3d.aspect = container.clientWidth / container.clientHeight;
            camera3d.updateProjectionMatrix();
            renderer3d.setSize(container.clientWidth, container.clientHeight);
        }

        function resetCamera() {
            if (!camera3d || !controls3d) return;
            camera3d.position.set(40, 35, 40);
            camera3d.lookAt(0, 5, 0);
            controls3d.target.set(0, 5, 0);
            controls3d.update();
        }

        function toggleAnimation() {
            isAnimating3d = !isAnimating3d;
            if (isAnimating3d) {
                animate3D();
            } else if (animationId3d) {
                cancelAnimationFrame(animationId3d);
            }
        }

        function toggleParticles() {
            showParticles3d = !showParticles3d;
            particles3d.forEach(system => {
                system.visible = showParticles3d;
            });
        }

        function changeViewMode() {
            if (!camera3d || !controls3d) return;

            viewMode3d = (viewMode3d + 1) % 3;

            switch(viewMode3d) {
                case 0: // Perspective
                    camera3d.position.set(40, 35, 40);
                    controls3d.target.set(0, 5, 0);
                    break;
                case 1: // Top view (Bird's eye)
                    camera3d.position.set(0, 80, 0);
                    controls3d.target.set(0, 0, 0);
                    break;
                case 2: // Side view
                    camera3d.position.set(60, 20, 0);
                    controls3d.target.set(0, 5, 0);
                    break;
            }

            camera3d.lookAt(controls3d.target);
            controls3d.update();
        }

        // Initialize 3D when tab is opened
        let is3DInitialized = false;

        // Update switchTab function to initialize 3D
        const originalSwitchTab = window.switchTab;
        window.switchTab = function(tabName, element) {
            originalSwitchTab(tabName, element);

            if (tabName === '3d' && !is3DInitialized) {
                setTimeout(() => {
                    init3DVisualization();
                    is3DInitialized = true;
                }, 100);
            }
        };

        // Start the app
        init();
    </script>
</body>
</html>
